{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"oidc-jwt-verifier","text":"<p><code>oidc-jwt-verifier</code> is a focused JWT access-token verification library for OIDC/JWKS issuers.</p> <p>It provides:</p> <ul> <li>A stable sync verifier (<code>JWTVerifier</code>) for existing Python services.</li> <li>A native async verifier (<code>AsyncJWTVerifier</code>) for ASGI applications.</li> <li>First-class FastAPI and Starlette integration helpers.</li> <li>Strict fail-closed security defaults with RFC 6750-compatible error headers.</li> </ul>"},{"location":"#what-this-library-verifies","title":"What This Library Verifies","text":"<p>For each token, the verifier enforces:</p> <ul> <li>Signature validation against keys from a configured JWKS URL.</li> <li>Issuer (<code>iss</code>) and audience (<code>aud</code>) checks.</li> <li>Time-based checks (<code>exp</code>, <code>nbf</code>).</li> <li>Algorithm allowlist enforcement, including rejection of <code>alg=none</code>.</li> <li>Authorization checks for required scopes and permissions.</li> </ul> <p>It also rejects unsafe JWT header parameters (<code>jku</code>, <code>x5u</code>, <code>crit</code>) and never derives key endpoints from token headers.</p>"},{"location":"#choose-your-path","title":"Choose Your Path","text":"<ul> <li>New to the package: Getting Started</li> <li>Sync services: Usage: Sync</li> <li>Async/ASGI services: Usage: Async</li> <li>Framework integration:</li> <li>FastAPI</li> <li>Starlette</li> <li>Operational details:</li> <li>Configuration</li> <li>Errors</li> <li>Security</li> <li>Migration</li> </ul>"},{"location":"#design-scope","title":"Design Scope","text":"<p>In scope:</p> <ul> <li>Verification of signed JWT access tokens with explicit issuer/audience/JWKS configuration.</li> <li>Consistent authentication/authorization error semantics.</li> <li>Sync and async verification paths with shared policy behavior.</li> </ul> <p>Out of scope:</p> <ul> <li>OAuth/OIDC client flows.</li> <li>OIDC discovery and automatic endpoint derivation.</li> <li>Session management.</li> </ul>"},{"location":"alternatives/","title":"Alternatives","text":"<p>This project is intentionally narrow: verify API access tokens from a known OIDC issuer with strict defaults and predictable errors.</p>"},{"location":"alternatives/#when-this-package-fits-best","title":"When This Package Fits Best","text":"<p>Use <code>oidc-jwt-verifier</code> when you want:</p> <ul> <li>Explicit issuer, audience, and JWKS URL configuration</li> <li>Built-in fail-closed JWT hardening</li> <li>Scope and permission enforcement</li> <li>Matching sync and async verification behavior</li> <li>Ready-to-use FastAPI and Starlette integration helpers</li> </ul>"},{"location":"alternatives/#when-another-approach-may-fit-better","title":"When Another Approach May Fit Better","text":""},{"location":"alternatives/#direct-pyjwt-usage","title":"Direct PyJWT usage","text":"<p>Use PyJWT directly when you need full control and are willing to own policy and error mapping details.</p> <ul> <li>https://pyjwt.readthedocs.io/en/stable/</li> </ul>"},{"location":"alternatives/#discovery-driven-verifier-packages","title":"Discovery-driven verifier packages","text":"<p>Use discovery-oriented packages when you prefer automatic OIDC metadata resolution (<code>.well-known/openid-configuration</code>) instead of explicit <code>jwks_url</code> setup.</p>"},{"location":"alternatives/#framework-specific-auth-packages","title":"Framework-specific auth packages","text":"<p>Use framework-specific auth libraries when you want deep integration with one framework and are comfortable with tighter framework coupling.</p>"},{"location":"alternatives/#general-jose-libraries","title":"General JOSE libraries","text":"<p>Use Authlib, joserfc, or python-jose when you need broader JOSE features beyond access-token verification.</p> <ul> <li>https://docs.authlib.org/en/latest/jose/jwt.html</li> <li>https://pypi.org/project/joserfc/</li> <li>https://pypi.org/project/python-jose/</li> </ul>"},{"location":"alternatives/#design-trade-off","title":"Design Trade-off","text":"<p><code>oidc-jwt-verifier</code> favors explicit configuration and small surface area over auto-discovery and broad feature scope. That trade-off keeps verification behavior predictable across frameworks and runtime models.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#015-2026-02-12","title":"0.1.5 (2026-02-12)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>integrations: add fastapi and starlette auth helpers (cdbae89)</li> <li>verifier: add async support and framework integrations (e69dbcd)</li> <li>verifier: add native async verifier and shared policy core (a8e6f40)</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>async: address PR #10 review feedback (b77433c)</li> <li>commit all pending changes (aaa743c)</li> <li>harden mypy Any checks and align CI extras install (25c8a6e)</li> <li>integrations: resolve PR #10 review threads (b506f98)</li> </ul>"},{"location":"changelog/#014-2026-02-12","title":"0.1.4 (2026-02-12)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>jwt: enforce minimum cryptographic key length (459c160)</li> <li>verifier: align with PyJWT 2.11 typing and key checks (7bcd8bf)</li> </ul>"},{"location":"changelog/#013-2025-12-18","title":"0.1.3 (2025-12-18)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>docs: add missing Documentation badge to docs/index.md (dfdf6ae)</li> </ul>"},{"location":"changelog/#012-2025-12-18","title":"0.1.2 (2025-12-18)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>docs: resolve MkDocs Material rendering issues and modernize deployment (89fefb0)</li> <li>docs: resolve MkDocs Material rendering issues and modernize deployment (2018920)</li> </ul>"},{"location":"changelog/#011-2025-12-18","title":"0.1.1 (2025-12-18)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>add core JWT verification library with automated release pipeline (61862b5)</li> <li>jwt-verifier: add core JWT verification library (cf67629)</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>address additional PR review comments (f8132f8)</li> <li>address PR review comments (b12bf0a)</li> <li>persist stripped scope_claim and permissions_claim values (c8290c5)</li> <li>update PyJWT to &gt;=2.10.1 to address CVE-2024-53861 (3fe5e8f)</li> <li>verifier: catch DecodeError in header parse (df76b3c)</li> <li>verifier: narrow decode exceptions in audience loop (d2a9fd5)</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<ul> <li>Initial release of the shared JWT verification core.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p><code>AuthConfig</code> is the canonical verifier configuration object. It is immutable (<code>frozen=True</code>) and validates inputs at construction time.</p>"},{"location":"configuration/#required-fields","title":"Required Fields","text":"<ul> <li><code>issuer</code>: expected <code>iss</code> value</li> <li><code>audience</code>: expected <code>aud</code> value(s), single string or sequence</li> <li><code>jwks_url</code>: URL of trusted JWKS endpoint</li> </ul> <pre><code>from oidc_jwt_verifier import AuthConfig\n\nconfig = AuthConfig(\n    issuer=\"https://issuer.example/\",\n    audience=(\"https://api.example\", \"https://api-backup.example\"),\n    jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n)\n</code></pre>"},{"location":"configuration/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>allowed_algs</code> <code>(\"RS256\",)</code> Allowed JWT signing algorithms. <code>none</code> is always rejected. <code>leeway_s</code> <code>0</code> Clock skew tolerance for <code>exp</code>/<code>nbf</code> checks. <code>jwks_timeout_s</code> <code>3.0</code> HTTP timeout (seconds) for JWKS fetch requests. <code>jwks_cache_ttl_s</code> <code>300.0</code> JWKS document cache TTL in seconds. <code>jwks_max_cached_keys</code> <code>16</code> Maximum cached signing keys by <code>kid</code>. <code>enforce_minimum_key_length</code> <code>True</code> Enforce PyJWT minimum key length checks. <code>required_scopes</code> <code>()</code> Required scopes for authorization success. <code>required_permissions</code> <code>()</code> Required permissions for authorization success. <code>scope_claim</code> <code>\"scope\"</code> Claim name used for scope extraction. <code>permissions_claim</code> <code>\"permissions\"</code> Claim name used for permission extraction."},{"location":"configuration/#validation-rules","title":"Validation Rules","text":"<p><code>AuthConfig</code> raises <code>ValueError</code> when configuration is invalid.</p> <p>Common examples:</p> <ul> <li>Empty <code>issuer</code>, <code>audience</code>, or <code>jwks_url</code></li> <li><code>allowed_algs</code> missing or containing <code>none</code></li> <li><code>leeway_s &lt; 0</code></li> <li><code>jwks_timeout_s &lt;= 0</code></li> <li><code>jwks_cache_ttl_s</code> outside <code>(0, 86400]</code></li> <li><code>jwks_max_cached_keys</code> outside <code>(0, 1024]</code></li> </ul>"},{"location":"configuration/#authorization-claim-shapes","title":"Authorization Claim Shapes","text":"<ul> <li><code>scope_claim</code>: supports space-delimited string or list of strings</li> <li><code>permissions_claim</code>: supports list of strings or space-delimited string</li> </ul> <p>Authorization failures return <code>AuthError</code> with HTTP <code>403</code>.</p>"},{"location":"configuration/#configuration-tips","title":"Configuration Tips","text":"<ul> <li>Reuse one config object per issuer/audience policy.</li> <li>Keep <code>allowed_algs</code> explicit and minimal.</li> <li>Point <code>jwks_url</code> to a trusted issuer endpoint only.</li> <li>Keep <code>jwks_timeout_s</code> low in API services to fail fast under network issues.</li> </ul>"},{"location":"errors/","title":"Errors","text":"<p>The library raises one public exception type: <code>AuthError</code>.</p> <p><code>AuthError</code> contains:</p> <ul> <li><code>code</code>: stable machine-readable identifier</li> <li><code>message</code>: human-readable description</li> <li><code>status_code</code>: HTTP <code>401</code> or <code>403</code></li> <li><code>required_scopes</code>: populated for <code>insufficient_scope</code></li> <li><code>required_permissions</code>: populated for <code>insufficient_permissions</code></li> </ul>"},{"location":"errors/#error-handling-pattern","title":"Error Handling Pattern","text":"<pre><code>from oidc_jwt_verifier import AuthError\n\ntry:\n    claims = verifier.verify_access_token(token)\nexcept AuthError as err:\n    status = err.status_code\n    code = err.code\n    header = err.www_authenticate_header(realm=\"api\")\n</code></pre>"},{"location":"errors/#error-codes","title":"Error Codes","text":"Code Status Meaning <code>missing_token</code> 401 Token missing or blank. <code>malformed_token</code> 401 Token format or header is invalid. <code>forbidden_header</code> 401 Token header contains forbidden fields (<code>jku</code>, <code>x5u</code>, <code>crit</code>). <code>disallowed_alg</code> 401 Signing algorithm is not permitted. <code>missing_kid</code> 401 Token header has no usable <code>kid</code>. <code>token_expired</code> 401 <code>exp</code> is in the past. <code>token_not_yet_valid</code> 401 <code>nbf</code> is in the future. <code>invalid_issuer</code> 401 <code>iss</code> does not match configured issuer. <code>invalid_audience</code> 401 <code>aud</code> does not match configured audience(s). <code>missing_claim</code> 401 Required JWT claim is missing. <code>invalid_token</code> 401 Signature/claim/key validation failed. <code>jwks_fetch_failed</code> 401 JWKS endpoint request failed (network/HTTP). <code>jwks_error</code> 401 JWKS payload or key parsing failed. <code>key_not_found</code> 401 No key in JWKS matched token <code>kid</code>. <code>insufficient_scope</code> 403 Required scopes are missing. <code>insufficient_permissions</code> 403 Required permissions are missing."},{"location":"errors/#rfc-6750-header-output","title":"RFC 6750 Header Output","text":"<p>Use <code>AuthError.www_authenticate_header()</code> to generate standards-compliant bearer challenge headers.</p> <ul> <li>For <code>401</code>, <code>error</code> is <code>invalid_token</code>.</li> <li>For <code>403</code>, <code>error</code> is <code>insufficient_scope</code>.</li> <li>Missing scopes/permissions are included when available.</li> </ul> <p>Example output:</p> <pre><code>Bearer realm=\"api\", error=\"invalid_token\", error_description=\"Token is expired\"\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python <code>&gt;=3.10</code></li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install only the sync verifier:</p> <pre><code>pip install oidc-jwt-verifier\n</code></pre> <p>Install async support:</p> <pre><code>pip install \"oidc-jwt-verifier[async]\"\n</code></pre> <p>Install framework helpers:</p> <pre><code>pip install \"oidc-jwt-verifier[fastapi]\"\npip install \"oidc-jwt-verifier[starlette]\"\n</code></pre>"},{"location":"getting-started/#first-sync-verification","title":"First Sync Verification","text":"<pre><code>from oidc_jwt_verifier import AuthConfig, JWTVerifier\n\nconfig = AuthConfig(\n    issuer=\"https://issuer.example/\",\n    audience=\"https://api.example\",\n    jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n)\n\nverifier = JWTVerifier(config)\nclaims = verifier.verify_access_token(token)\n</code></pre>"},{"location":"getting-started/#first-async-verification","title":"First Async Verification","text":"<pre><code>from oidc_jwt_verifier import AuthConfig\nfrom oidc_jwt_verifier.async_verifier import AsyncJWTVerifier\n\nconfig = AuthConfig(\n    issuer=\"https://issuer.example/\",\n    audience=\"https://api.example\",\n    jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n)\n\nasync def verify(token: str) -&gt; dict[str, object]:\n    async with AsyncJWTVerifier(config) as verifier:\n        return await verifier.verify_access_token(token)\n</code></pre> <p>Note: In production services, prefer reusing a single <code>AsyncJWTVerifier</code> instance for the app/process lifetime and close it on shutdown.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Configure claim and cache behavior: Configuration</li> <li>Handle verifier errors correctly: Errors</li> <li>Integrate with your framework:</li> <li>FastAPI</li> <li>Starlette</li> </ul>"},{"location":"migration/","title":"Migration Guide","text":"<p>This release adds async and framework integration features without breaking the existing sync API.</p>"},{"location":"migration/#compatibility-summary","title":"Compatibility Summary","text":"Existing usage Required change <code>AuthConfig</code>, <code>AuthError</code>, <code>JWTVerifier</code> None Sync-only installation None Async usage Install <code>oidc-jwt-verifier[async]</code> FastAPI helpers Install <code>oidc-jwt-verifier[fastapi]</code> Starlette helpers Install <code>oidc-jwt-verifier[starlette]</code>"},{"location":"migration/#if-you-already-use-the-sync-verifier","title":"If You Already Use the Sync Verifier","text":"<p>No migration is required.</p> <pre><code>from oidc_jwt_verifier import AuthConfig, JWTVerifier\n\nverifier = JWTVerifier(AuthConfig(...))\nclaims = verifier.verify_access_token(token)\n</code></pre>"},{"location":"migration/#move-to-native-async-verification","title":"Move to Native Async Verification","text":"<ol> <li>Install async extra: <code>pip install \"oidc-jwt-verifier[async]\"</code></li> <li>Replace <code>JWTVerifier</code> with <code>AsyncJWTVerifier</code></li> <li>Use <code>await verifier.verify_access_token(...)</code></li> <li>Close verifier-owned resources with <code>await verifier.aclose()</code> or <code>async with</code></li> </ol> <pre><code>from oidc_jwt_verifier.async_verifier import AsyncJWTVerifier\n\nasync with AsyncJWTVerifier(config) as verifier:\n    claims = await verifier.verify_access_token(token)\n</code></pre>"},{"location":"migration/#fastapi-migration","title":"FastAPI Migration","text":"<p>Use <code>create_async_bearer_dependency()</code> for async endpoints.</p> <pre><code>from oidc_jwt_verifier.integrations.fastapi import create_async_bearer_dependency\n\nauth = create_async_bearer_dependency(verifier, realm=\"api\")\n</code></pre> <p>If you must keep <code>JWTVerifier</code>, use <code>create_sync_bearer_dependency()</code> with threadpool offload enabled.</p>"},{"location":"migration/#starlette-migration","title":"Starlette Migration","text":"<p>Add <code>BearerAuthMiddleware</code> and read claims from request state.</p> <pre><code>app.add_middleware(BearerAuthMiddleware, verifier=verifier, realm=\"api\")\n</code></pre>"},{"location":"migration/#rollout-checklist","title":"Rollout Checklist","text":"<ul> <li>Install the correct extra for your runtime.</li> <li>Reuse long-lived verifier instances.</li> <li>Add shutdown cleanup for async verifier ownership paths.</li> <li>Confirm <code>WWW-Authenticate</code> headers in integration tests.</li> <li>Validate required scopes/permissions behavior in your API routes.</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>This page documents the package public API and optional integration modules.</p>"},{"location":"reference/#core-public-api","title":"Core Public API","text":"<p>Available in the base install:</p> <ul> <li><code>AuthConfig</code></li> <li><code>AuthError</code></li> <li><code>JWTVerifier</code></li> </ul>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig","title":"<code>AuthConfig(issuer: str, audience: str | Sequence[str], jwks_url: str, allowed_algs: Sequence[str] = ('RS256',), leeway_s: int = 0, jwks_timeout_s: float = 3.0, jwks_cache_ttl_s: float = 300.0, jwks_max_cached_keys: int = 16, enforce_minimum_key_length: bool = True, required_scopes: Sequence[str] = (), required_permissions: Sequence[str] = (), scope_claim: str = 'scope', permissions_claim: str = 'permissions')</code>  <code>dataclass</code>","text":"<p>Immutable configuration for JWT verification.</p> <p>This dataclass holds all settings required by <code>JWTVerifier</code> to validate JWTs against an OIDC provider. The configuration is frozen (immutable) and uses slots for memory efficiency.</p> <p>All string inputs are stripped of leading/trailing whitespace during validation. Sequences are normalized to tuples.</p> <p>Attributes:</p> Name Type Description <code>issuer</code> <code>str</code> <p>The expected <code>iss</code> claim value. Must match the token issuer exactly. Typically the OIDC provider URL (e.g., <code>https://example.auth0.com/</code>).</p> <code>audience</code> <code>str | Sequence[str]</code> <p>One or more expected <code>aud</code> claim values. The token must contain at least one matching audience. Accepts a single string or a sequence of strings.</p> <code>jwks_url</code> <code>str</code> <p>The URL to fetch the JSON Web Key Set from. This URL is used for all key lookups; the verifier never derives JWKS URLs from token headers.</p> <code>allowed_algs</code> <code>Sequence[str]</code> <p>Permitted signing algorithms. Defaults to <code>(\"RS256\",)</code>. The <code>none</code> algorithm is always rejected regardless of this setting.</p> <code>leeway_s</code> <code>int</code> <p>Clock skew tolerance in seconds for <code>exp</code> and <code>nbf</code> claim validation. Defaults to 0.</p> <code>jwks_timeout_s</code> <code>float</code> <p>HTTP timeout in seconds for JWKS fetches. Supports fractional seconds. Defaults to 3.0.</p> <code>jwks_cache_ttl_s</code> <code>float</code> <p>Time-to-live in seconds for cached JWKS data. Supports fractional seconds and must be in the range (0, 86400]. Defaults to 300.0.</p> <code>jwks_max_cached_keys</code> <code>int</code> <p>Maximum number of signing keys to cache. Must be in the range (0, 1024]. Defaults to 16.</p> <code>enforce_minimum_key_length</code> <code>bool</code> <p>Whether to reject JWTs signed with cryptographic keys below PyJWT minimum recommendations. Defaults to <code>True</code>.</p> <code>required_scopes</code> <code>Sequence[str]</code> <p>Scopes that must be present in the token for authorization to succeed. Checked against the <code>scope_claim</code>. Defaults to an empty tuple (no scope requirements).</p> <code>required_permissions</code> <code>Sequence[str]</code> <p>Permissions that must be present in the token. Checked against the <code>permissions_claim</code>. Defaults to an empty tuple.</p> <code>scope_claim</code> <code>str</code> <p>The claim name containing OAuth 2.0 scopes. Defaults to <code>\"scope\"</code>.</p> <code>permissions_claim</code> <code>str</code> <p>The claim name containing permissions (commonly used by Auth0). Defaults to <code>\"permissions\"</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any validation constraint is violated during construction. Specific conditions include: - Empty or whitespace-only <code>issuer</code>, <code>jwks_url</code>, or   <code>audience</code>. - Empty or whitespace-only <code>allowed_algs</code>, or inclusion of   the <code>none</code> algorithm. - Negative <code>leeway_s</code>. - Non-positive <code>jwks_timeout_s</code>. - <code>jwks_cache_ttl_s</code> outside (0, 86400]. - <code>jwks_max_cached_keys</code> outside (0, 1024]. - Empty or whitespace-only <code>scope_claim</code> or   <code>permissions_claim</code>.</p> <p>Examples:</p> <p>Minimal configuration for Auth0:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; config.audiences\n('https://api.example.com',)\n&gt;&gt;&gt; config.allowed_algorithms\n('RS256',)\n</code></pre> <p>Configuration with multiple audiences and scope requirements:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=[\n...         \"https://api.example.com\",\n...         \"https://api2.example.com\",\n...     ],\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     allowed_algs=[\"RS256\", \"RS384\"],\n...     required_scopes=[\"read:users\", \"write:users\"],\n... )\n&gt;&gt;&gt; config.audiences\n('https://api.example.com', 'https://api2.example.com')\n&gt;&gt;&gt; config.required_scope_set\n{'read:users', 'write:users'}\n</code></pre> <p>Invalid configuration raises ValueError:</p> <pre><code>&gt;&gt;&gt; AuthConfig(\n...     issuer=\"\",\n...     audience=\"api\",\n...     jwks_url=\"https://example.com/.well-known/jwks.json\",\n... )\nTraceback (most recent call last):\n    ...\nValueError: issuer must be non-empty\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.audiences","title":"<code>audiences: tuple[str, ...]</code>  <code>property</code>","text":"<p>Return the configured audiences as a tuple.</p> <p>This property provides consistent tuple access regardless of whether the <code>audience</code> attribute was initialized with a single string or a sequence.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple of audience strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; config.audiences\n('https://api.example.com',)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.allowed_algorithms","title":"<code>allowed_algorithms: tuple[str, ...]</code>  <code>property</code>","text":"<p>Return the allowed algorithms as a tuple.</p> <p>This property provides consistent tuple access regardless of whether the <code>allowed_algs</code> attribute was initialized with a single string or a sequence.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple of algorithm name strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     allowed_algs=[\"RS256\", \"ES256\"],\n... )\n&gt;&gt;&gt; config.allowed_algorithms\n('RS256', 'ES256')\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.required_scope_set","title":"<code>required_scope_set: set[str]</code>  <code>property</code>","text":"<p>Return the required scopes as a set for efficient membership testing.</p> <p>Empty strings in the <code>required_scopes</code> sequence are filtered out.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of non-empty scope strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     required_scopes=[\"read:users\", \"write:users\"],\n... )\n&gt;&gt;&gt; config.required_scope_set == {\"read:users\", \"write:users\"}\nTrue\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.required_permission_set","title":"<code>required_permission_set: set[str]</code>  <code>property</code>","text":"<p>Return the required permissions as a set for efficient membership testing.</p> <p>Empty strings in the <code>required_permissions</code> sequence are filtered out.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of non-empty permission strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     required_permissions=[\"admin\", \"editor\"],\n... )\n&gt;&gt;&gt; config.required_permission_set == {\"admin\", \"editor\"}\nTrue\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"<p>Validate and normalize configuration values after initialization.</p> <p>This method runs automatically after dataclass initialization. It strips whitespace from string values, normalizes sequences to tuples, and validates all constraints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any validation constraint is violated.</p> Source code in <code>oidc_jwt_verifier/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate and normalize configuration values after initialization.\n\n    This method runs automatically after dataclass initialization. It\n    strips whitespace from string values, normalizes sequences to tuples,\n    and validates all constraints.\n\n    Raises:\n        ValueError: If any validation constraint is violated.\n    \"\"\"\n    issuer = self.issuer.strip()\n    if not issuer:\n        raise ValueError(\"issuer must be non-empty\")\n    object.__setattr__(self, \"issuer\", issuer)\n\n    jwks_url = self.jwks_url.strip()\n    if not jwks_url:\n        raise ValueError(\"jwks_url must be non-empty\")\n    object.__setattr__(self, \"jwks_url\", jwks_url)\n\n    audiences = tuple(\n        a.strip() for a in _normalize_str_sequence(self.audience)\n    )\n    if not audiences or any(not a for a in audiences):\n        raise ValueError(\"audience must be non-empty\")\n    object.__setattr__(self, \"audience\", audiences)\n\n    allowed_algs = tuple(\n        a.strip() for a in _normalize_str_sequence(self.allowed_algs)\n    )\n    if not allowed_algs or any(not a for a in allowed_algs):\n        raise ValueError(\"allowed_algs must be non-empty\")\n    if any(a.lower() == \"none\" for a in allowed_algs):\n        raise ValueError(\"allowed_algs must not include 'none'\")\n    object.__setattr__(self, \"allowed_algs\", allowed_algs)\n\n    if self.leeway_s &lt; 0:\n        raise ValueError(\"leeway_s must be &gt;= 0\")\n\n    if self.jwks_timeout_s &lt;= 0:\n        raise ValueError(\"jwks_timeout_s must be &gt; 0\")\n    if not 0 &lt; self.jwks_cache_ttl_s &lt;= 24 * 60 * 60:\n        raise ValueError(\"jwks_cache_ttl_s must be in (0, 86400]\")\n    if not 0 &lt; self.jwks_max_cached_keys &lt;= 1024:\n        raise ValueError(\"jwks_max_cached_keys must be in (0, 1024]\")\n\n    object.__setattr__(\n        self,\n        \"required_scopes\",\n        tuple(\n            s.strip() for s in _normalize_str_sequence(self.required_scopes)\n        ),\n    )\n    object.__setattr__(\n        self,\n        \"required_permissions\",\n        tuple(\n            p.strip()\n            for p in _normalize_str_sequence(self.required_permissions)\n        ),\n    )\n\n    scope_claim = self.scope_claim.strip()\n    if not scope_claim:\n        raise ValueError(\"scope_claim must be non-empty\")\n    object.__setattr__(self, \"scope_claim\", scope_claim)\n\n    permissions_claim = self.permissions_claim.strip()\n    if not permissions_claim:\n        raise ValueError(\"permissions_claim must be non-empty\")\n    object.__setattr__(self, \"permissions_claim\", permissions_claim)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthError","title":"<code>AuthError(*, code: str, message: str, status_code: int, required_scopes: Iterable[str] = (), required_permissions: Iterable[str] = ())</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised on authentication or authorization failure.</p> <p>This exception provides structured error information including a stable error code for programmatic handling, an HTTP status code (401 for authentication failures, 403 for authorization failures), and a method to generate RFC 6750-compliant WWW-Authenticate header values.</p> <p>The exception message is accessible via the standard <code>str()</code> conversion or the <code>message</code> attribute.</p> <p>Attributes:</p> Name Type Description <code>code</code> <p>A stable string identifier for the error type. Common values include <code>\"invalid_token\"</code>, <code>\"token_expired\"</code>, <code>\"insufficient_scope\"</code>, and <code>\"missing_token\"</code>. Suitable for programmatic error handling and logging.</p> <code>message</code> <p>A human-readable description of the error. This is also set as the exception message.</p> <code>status_code</code> <p>The HTTP status code to return. Must be 401 (Unauthorized) for authentication errors or 403 (Forbidden) for authorization errors.</p> <code>required_scopes</code> <p>A tuple of scope strings that were required but missing from the token. Populated for <code>insufficient_scope</code> errors; empty for other error types.</p> <code>required_permissions</code> <p>A tuple of permission strings that were required but missing from the token. Populated for <code>insufficient_permissions</code> errors; empty for other error types.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>status_code</code> is not 401 or 403.</p> <p>Examples:</p> <p>Creating an authentication error (401):</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"token_expired\",\n...     message=\"Token is expired\",\n...     status_code=401,\n... )\n&gt;&gt;&gt; str(error)\n'Token is expired'\n&gt;&gt;&gt; error.code\n'token_expired'\n&gt;&gt;&gt; error.status_code\n401\n</code></pre> <p>Creating an authorization error (403) with scope requirements:</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"insufficient_scope\",\n...     message=\"Insufficient scope\",\n...     status_code=403,\n...     required_scopes=[\"read:users\", \"write:users\"],\n... )\n&gt;&gt;&gt; error.required_scopes\n('read:users', 'write:users')\n</code></pre> <p>Generating a WWW-Authenticate header:</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"invalid_token\",\n...     message=\"Malformed token\",\n...     status_code=401,\n... )\n&gt;&gt;&gt; error.www_authenticate_header(realm=\"api\")\n'Bearer realm=\"api\", error=\"invalid_token\", error_description=\"Malformed token\"'\n</code></pre> <p>Invalid status code raises ValueError:</p> <pre><code>&gt;&gt;&gt; AuthError(code=\"error\", message=\"msg\", status_code=500)\nTraceback (most recent call last):\n    ...\nValueError: status_code must be 401 or 403\n</code></pre> <p>Initialize an authentication or authorization error.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>A stable string identifier for the error type.</p> required <code>message</code> <code>str</code> <p>A human-readable error description.</p> required <code>status_code</code> <code>int</code> <p>The HTTP status code (must be 401 or 403).</p> required <code>required_scopes</code> <code>Iterable[str]</code> <p>Scopes that were required but missing. Defaults to an empty tuple.</p> <code>()</code> <code>required_permissions</code> <code>Iterable[str]</code> <p>Permissions that were required but missing. Defaults to an empty tuple.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>status_code</code> is not 401 or 403.</p> Source code in <code>oidc_jwt_verifier/errors.py</code> <pre><code>def __init__(\n    self,\n    *,\n    code: str,\n    message: str,\n    status_code: int,\n    required_scopes: Iterable[str] = (),\n    required_permissions: Iterable[str] = (),\n) -&gt; None:\n    \"\"\"Initialize an authentication or authorization error.\n\n    Args:\n        code: A stable string identifier for the error type.\n        message: A human-readable error description.\n        status_code: The HTTP status code (must be 401 or 403).\n        required_scopes: Scopes that were required but missing.\n            Defaults to an empty tuple.\n        required_permissions: Permissions that were required but missing.\n            Defaults to an empty tuple.\n\n    Raises:\n        ValueError: If ``status_code`` is not 401 or 403.\n    \"\"\"\n    if status_code not in (401, 403):\n        raise ValueError(\"status_code must be 401 or 403\")\n    super().__init__(message)\n    self.code = code\n    self.message = message\n    self.status_code = status_code\n    self.required_scopes = tuple(required_scopes)\n    self.required_permissions = tuple(required_permissions)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthError.www_authenticate_header","title":"<code>www_authenticate_header(*, realm: str | None = None) -&gt; str</code>","text":"<p>Generate an RFC 6750-compliant WWW-Authenticate header value.</p> <p>Constructs a Bearer authentication challenge suitable for use as the value of an HTTP WWW-Authenticate header. The challenge includes the error type (mapped to RFC 6750 error codes) and a description.</p> <p>RFC 6750 defines two relevant error codes: - <code>invalid_token</code>: Used for 401 errors (authentication failures). - <code>insufficient_scope</code>: Used for 403 errors (authorization failures).</p> <p>If <code>required_scopes</code> is non-empty, a <code>scope</code> parameter is included listing the missing scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm</code> <code>str | None</code> <p>Optional protection space identifier. If provided, it appears first in the challenge parameters. Common values include the API name or domain.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string suitable for use as the WWW-Authenticate header value.</p> <code>str</code> <p>The format is <code>Bearer param1=\"value1\", param2=\"value2\", ...</code>.</p> <p>Examples:</p> <p>Basic authentication error:</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"invalid_token\",\n...     message=\"Token is expired\",\n...     status_code=401,\n... )\n&gt;&gt;&gt; error.www_authenticate_header()\n'Bearer error=\"invalid_token\", error_description=\"Token is expired\"'\n</code></pre> <p>With realm:</p> <pre><code>&gt;&gt;&gt; error.www_authenticate_header(realm=\"my-api\")\n'Bearer realm=\"my-api\", error=\"invalid_token\", error_description=\"Token is expired\"'\n</code></pre> <p>Authorization error with required scopes:</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"insufficient_scope\",\n...     message=\"Insufficient scope\",\n...     status_code=403,\n...     required_scopes=[\"read:users\"],\n... )\n&gt;&gt;&gt; header = error.www_authenticate_header()\n&gt;&gt;&gt; \"insufficient_scope\" in header\nTrue\n&gt;&gt;&gt; \"read:users\" in header\nTrue\n</code></pre> Source code in <code>oidc_jwt_verifier/errors.py</code> <pre><code>def www_authenticate_header(self, *, realm: str | None = None) -&gt; str:\n    \"\"\"Generate an RFC 6750-compliant WWW-Authenticate header value.\n\n    Constructs a Bearer authentication challenge suitable for use as the\n    value of an HTTP WWW-Authenticate header. The challenge includes\n    the error type (mapped to RFC 6750 error codes) and a description.\n\n    RFC 6750 defines two relevant error codes:\n    - ``invalid_token``: Used for 401 errors (authentication failures).\n    - ``insufficient_scope``: Used for 403 errors (authorization failures).\n\n    If ``required_scopes`` is non-empty, a ``scope`` parameter is\n    included listing the missing scopes.\n\n    Args:\n        realm: Optional protection space identifier. If provided, it\n            appears first in the challenge parameters. Common values\n            include the API name or domain.\n\n    Returns:\n        A string suitable for use as the WWW-Authenticate header value.\n        The format is ``Bearer param1=\"value1\", param2=\"value2\", ...``.\n\n    Examples:\n        Basic authentication error:\n\n        &gt;&gt;&gt; error = AuthError(\n        ...     code=\"invalid_token\",\n        ...     message=\"Token is expired\",\n        ...     status_code=401,\n        ... )\n        &gt;&gt;&gt; error.www_authenticate_header()\n        'Bearer error=\"invalid_token\", error_description=\"Token is expired\"'\n\n        With realm:\n\n        &gt;&gt;&gt; error.www_authenticate_header(realm=\"my-api\")\n        'Bearer realm=\"my-api\", error=\"invalid_token\", error_description=\"Token is expired\"'\n\n        Authorization error with required scopes:\n\n        &gt;&gt;&gt; error = AuthError(\n        ...     code=\"insufficient_scope\",\n        ...     message=\"Insufficient scope\",\n        ...     status_code=403,\n        ...     required_scopes=[\"read:users\"],\n        ... )\n        &gt;&gt;&gt; header = error.www_authenticate_header()\n        &gt;&gt;&gt; \"insufficient_scope\" in header\n        True\n        &gt;&gt;&gt; \"read:users\" in header\n        True\n    \"\"\"\n    params: list[str] = []\n    if realm is not None:\n        params.append(f\"realm={_quote_rfc6750_value(realm)}\")\n\n    if self.status_code == 403:\n        rfc6750_error = \"insufficient_scope\"\n    else:\n        rfc6750_error = \"invalid_token\"\n\n    params.append(f\"error={_quote_rfc6750_value(rfc6750_error)}\")\n    params.append(f\"error_description={_quote_rfc6750_value(self.message)}\")\n\n    if self.required_scopes:\n        scope_str = \" \".join(self.required_scopes)\n        params.append(f\"scope={_quote_rfc6750_value(scope_str)}\")\n\n    if self.required_permissions:\n        permissions_str = \" \".join(self.required_permissions)\n        params.append(\n            f\"permissions={_quote_rfc6750_value(permissions_str)}\"\n        )\n\n    return \"Bearer \" + \", \".join(params)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.JWTVerifier","title":"<code>JWTVerifier(config: AuthConfig)</code>","text":"<p>Stateful JWT verifier for OIDC access tokens.</p> <p>This class performs complete JWT verification including:</p> <ol> <li>Header validation: Rejects tokens with dangerous headers    (<code>jku</code>, <code>x5u</code>, <code>crit</code>) and ensures the algorithm is in the    allowlist.</li> <li>Key retrieval: Fetches the signing key from the JWKS using the    token's <code>kid</code> header.</li> <li>Signature verification: Validates the cryptographic signature.</li> <li>Claim validation: Checks <code>iss</code>, <code>aud</code>, <code>exp</code>, and <code>nbf</code>    claims against configuration.</li> <li>Authorization enforcement: Verifies required scopes and    permissions are present (returns 403 on failure).</li> </ol> <p>The verifier maintains a cached JWKS client for efficient key lookups across multiple token verifications.</p> <p>Attributes:</p> Name Type Description <code>_config</code> <p>The authentication configuration.</p> <code>_jwks</code> <p>The JWKS client for signing key retrieval.</p> <code>_decoder</code> <p>A configured <code>jwt.PyJWT</code> instance used for token decoding.</p> <p>Examples:</p> <p>Basic token verification:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig, AuthError, JWTVerifier\n&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; verifier = JWTVerifier(config)\n&gt;&gt;&gt; claims = verifier.verify_access_token(token)\n&gt;&gt;&gt; claims[\"sub\"]\n'auth0|123456789'\n</code></pre> <p>Handling verification errors:</p> <pre><code>&gt;&gt;&gt; try:\n...     claims = verifier.verify_access_token(expired_token)\n... except AuthError as e:\n...     print(f\"Error: {e.code}, Status: {e.status_code}\")\n...     print(e.www_authenticate_header())\nError: token_expired, Status: 401\nBearer error=\"invalid_token\", error_description=\"Token is expired\"\n</code></pre> <p>Verifying tokens with scope requirements:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     required_scopes=[\"read:users\"],\n... )\n&gt;&gt;&gt; verifier = JWTVerifier(config)\n&gt;&gt;&gt; # Token without required scopes raises AuthError with 403\n&gt;&gt;&gt; claims = verifier.verify_access_token(\n...     token_without_scopes\n... )\nTraceback (most recent call last):\n    ...\nAuthError: Insufficient scope\n</code></pre> <p>Initialize a JWT verifier with the given configuration.</p> <p>Creates a JWKS client configured with the caching parameters from the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AuthConfig</code> <p>The authentication configuration specifying the issuer, audience, JWKS URL, allowed algorithms, and authorization requirements.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig\n&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; verifier = JWTVerifier(config)\n</code></pre> Source code in <code>oidc_jwt_verifier/verifier.py</code> <pre><code>def __init__(self, config: AuthConfig) -&gt; None:\n    \"\"\"Initialize a JWT verifier with the given configuration.\n\n    Creates a JWKS client configured with the caching parameters\n    from the provided configuration.\n\n    Args:\n        config: The authentication configuration specifying the\n            issuer, audience, JWKS URL, allowed algorithms, and\n            authorization requirements.\n\n    Examples:\n        &gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig\n        &gt;&gt;&gt; config = AuthConfig(\n        ...     issuer=\"https://example.auth0.com/\",\n        ...     audience=\"https://api.example.com\",\n        ...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n        ... )\n        &gt;&gt;&gt; verifier = JWTVerifier(config)  # doctest: +SKIP\n    \"\"\"\n    self._config = config\n    self._jwks = JWKSClient.from_config(config)\n    self._decoder = jwt.PyJWT(\n        options={\n            \"enforce_minimum_key_length\": config.enforce_minimum_key_length\n        }\n    )\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.JWTVerifier.verify_access_token","title":"<code>verify_access_token(token: str) -&gt; dict[str, Any]</code>","text":"<p>Verify an access token and return its claims.</p> <p>Performs the complete verification chain:</p> <ol> <li>Validates the token is non-empty.</li> <li>Parses and validates the token header (rejects <code>jku</code>, <code>x5u</code>,    <code>crit</code>; validates <code>alg</code> and <code>kid</code>).</li> <li>Fetches the signing key from the JWKS.</li> <li>Decodes and verifies the token signature.</li> <li>Validates standard claims (<code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>).</li> <li>Enforces required scopes and permissions.</li> </ol> <p>The method supports Auth0-style multi-audience tokens where the <code>aud</code> claim is an array. Verification succeeds if any configured audience matches any audience in the token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The encoded JWT access token string. Leading and trailing whitespace is stripped.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The decoded token payload as a dictionary. Contains all</p> <code>dict[str, Any]</code> <p>claims from the token including registered claims (<code>iss</code>,</p> <code>dict[str, Any]</code> <p><code>sub</code>, <code>aud</code>, <code>exp</code>, etc.) and any custom claims.</p> <p>Raises:</p> Type Description <code>AuthError</code> <p>On any verification failure. The error's <code>status_code</code> indicates the appropriate HTTP response: - 401 for authentication failures (missing token,   malformed token, invalid signature, expired token,   wrong issuer/audience). - 403 for authorization failures (insufficient scopes   or permissions).</p> <p>Specific error codes include: - <code>\"missing_token\"</code>: Empty or whitespace-only token. - <code>\"malformed_token\"</code>: Unparseable token or missing   <code>alg</code> header. - <code>\"forbidden_header\"</code>: Token contains <code>jku</code>,   <code>x5u</code>, or <code>crit</code> headers. - <code>\"disallowed_alg\"</code>: Algorithm not in allowlist or   is <code>none</code>. - <code>\"missing_kid\"</code>: Token lacks <code>kid</code> header. - <code>\"token_expired\"</code>: Token <code>exp</code> is in the past. - <code>\"token_not_yet_valid\"</code>: Token <code>nbf</code> is in the   future. - <code>\"invalid_issuer\"</code>: <code>iss</code> claim mismatch. - <code>\"invalid_audience\"</code>: <code>aud</code> claim mismatch. - <code>\"insufficient_scope\"</code>: Missing required scopes. - <code>\"insufficient_permissions\"</code>: Missing required   permissions.</p> <p>Examples:</p> <p>Successful verification:</p> <pre><code>&gt;&gt;&gt; claims = verifier.verify_access_token(\n...     valid_token\n... )\n&gt;&gt;&gt; claims[\"sub\"]\n'auth0|123456789'\n&gt;&gt;&gt; claims[\"aud\"]\n'https://api.example.com'\n</code></pre> <p>Missing token:</p> <pre><code>&gt;&gt;&gt; verifier.verify_access_token(\"\")\nTraceback (most recent call last):\n    ...\nAuthError: Missing access token\n</code></pre> <p>Expired token:</p> <pre><code>&gt;&gt;&gt; verifier.verify_access_token(expired_token)\nTraceback (most recent call last):\n    ...\nAuthError: Token is expired\n</code></pre> Source code in <code>oidc_jwt_verifier/verifier.py</code> <pre><code>def verify_access_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Verify an access token and return its claims.\n\n    Performs the complete verification chain:\n\n    1. Validates the token is non-empty.\n    2. Parses and validates the token header (rejects ``jku``, ``x5u``,\n       ``crit``; validates ``alg`` and ``kid``).\n    3. Fetches the signing key from the JWKS.\n    4. Decodes and verifies the token signature.\n    5. Validates standard claims (``iss``, ``aud``, ``exp``, ``nbf``).\n    6. Enforces required scopes and permissions.\n\n    The method supports Auth0-style multi-audience tokens where the\n    ``aud`` claim is an array. Verification succeeds if any configured\n    audience matches any audience in the token.\n\n    Args:\n        token: The encoded JWT access token string. Leading and\n            trailing whitespace is stripped.\n\n    Returns:\n        The decoded token payload as a dictionary. Contains all\n        claims from the token including registered claims (``iss``,\n        ``sub``, ``aud``, ``exp``, etc.) and any custom claims.\n\n    Raises:\n        AuthError: On any verification failure. The error's\n            ``status_code`` indicates the appropriate HTTP response:\n            - 401 for authentication failures (missing token,\n              malformed token, invalid signature, expired token,\n              wrong issuer/audience).\n            - 403 for authorization failures (insufficient scopes\n              or permissions).\n\n            Specific error codes include:\n            - ``\"missing_token\"``: Empty or whitespace-only token.\n            - ``\"malformed_token\"``: Unparseable token or missing\n              ``alg`` header.\n            - ``\"forbidden_header\"``: Token contains ``jku``,\n              ``x5u``, or ``crit`` headers.\n            - ``\"disallowed_alg\"``: Algorithm not in allowlist or\n              is ``none``.\n            - ``\"missing_kid\"``: Token lacks ``kid`` header.\n            - ``\"token_expired\"``: Token ``exp`` is in the past.\n            - ``\"token_not_yet_valid\"``: Token ``nbf`` is in the\n              future.\n            - ``\"invalid_issuer\"``: ``iss`` claim mismatch.\n            - ``\"invalid_audience\"``: ``aud`` claim mismatch.\n            - ``\"insufficient_scope\"``: Missing required scopes.\n            - ``\"insufficient_permissions\"``: Missing required\n              permissions.\n\n    Examples:\n        Successful verification:\n\n        &gt;&gt;&gt; claims = verifier.verify_access_token(\n        ...     valid_token\n        ... )  # doctest: +SKIP\n        &gt;&gt;&gt; claims[\"sub\"]  # doctest: +SKIP\n        'auth0|123456789'\n        &gt;&gt;&gt; claims[\"aud\"]  # doctest: +SKIP\n        'https://api.example.com'\n\n        Missing token:\n\n        &gt;&gt;&gt; verifier.verify_access_token(\"\")  # doctest: +SKIP\n        Traceback (most recent call last):\n            ...\n        AuthError: Missing access token\n\n        Expired token:\n\n        &gt;&gt;&gt; verifier.verify_access_token(expired_token)  # doctest: +SKIP\n        Traceback (most recent call last):\n            ...\n        AuthError: Token is expired\n    \"\"\"\n    token = token.strip()\n    if not token:\n        raise AuthError(\n            code=\"missing_token\",\n            message=\"Missing access token\",\n            status_code=401,\n        )\n\n    _, alg = parse_and_validate_header(\n        token, allowed_algorithms=self._config.allowed_algorithms\n    )\n    signing_key = self._jwks.get_signing_key_from_jwt(token)\n\n    payload = decode_and_validate_payload(\n        decoder=self._decoder,\n        token=token,\n        signing_key=signing_key,\n        algorithm=alg,\n        config=self._config,\n    )\n    enforce_authorization_claims(payload, config=self._config)\n    return payload\n</code></pre>"},{"location":"reference/#optional-async-api","title":"Optional Async API","text":"<p>Requires <code>pip install \"oidc-jwt-verifier[async]\"</code>.</p> <ul> <li><code>oidc_jwt_verifier.async_jwks.AsyncJWKSClient</code></li> <li><code>oidc_jwt_verifier.async_verifier.AsyncJWTVerifier</code></li> </ul>"},{"location":"reference/#oidc_jwt_verifier.async_jwks.AsyncJWKSClient","title":"<code>AsyncJWKSClient(_config: AuthConfig, _client: httpx.AsyncClient, _owns_client: bool, _max_fetch_attempts: int = 2, _jwk_set_cache: PyJWKSet | None = None, _jwk_set_expiry_monotonic: float = 0.0, _key_cache: OrderedDict[str, PyJWK] = OrderedDict(), _lock: asyncio.Lock = asyncio.Lock())</code>  <code>dataclass</code>","text":"<p>Asynchronous JWKS client with TTL and key caching.</p> <p>The client supports:</p> <ul> <li>Async JWKS fetches via <code>httpx.AsyncClient</code>.</li> <li>JWKS document caching with <code>jwks_cache_ttl_s</code>.</li> <li>Key-object caching with <code>jwks_max_cached_keys</code>.</li> <li>Error mapping to stable <code>AuthError</code> codes.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>_config</code> <code>AuthConfig</code> <p>Auth configuration.</p> required <code>_client</code> <code>AsyncClient</code> <p>Async HTTP client used for JWKS fetches.</p> required <code>_owns_client</code> <code>bool</code> <p>Whether this instance must close <code>_client</code> on <code>aclose</code>.</p> required <code>_max_fetch_attempts</code> <code>int</code> <p>Number of total fetch attempts for transient request failures. Minimum value is <code>1</code>.</p> <code>2</code> <code>_jwk_set_cache</code> <code>PyJWKSet | None</code> <p>Cached parsed JWKS set.</p> <code>None</code> <code>_jwk_set_expiry_monotonic</code> <code>float</code> <p>Monotonic timestamp when JWKS cache expires.</p> <code>0.0</code> <code>_key_cache</code> <code>OrderedDict[str, PyJWK]</code> <p>LRU-like cache of <code>kid</code> to <code>PyJWK</code>.</p> <code>OrderedDict()</code> <code>_lock</code> <code>Lock</code> <p>Async lock protecting cache state.</p> <code>Lock()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig\n&gt;&gt;&gt; from oidc_jwt_verifier.async_jwks import AsyncJWKSClient\n&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://issuer.example/\",\n...     audience=\"https://api.example\",\n...     jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; client = AsyncJWKSClient.from_config(config)\n&gt;&gt;&gt; # await client.get_signing_key_from_jwt(token)\n&gt;&gt;&gt; # await client.aclose()\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_jwks.AsyncJWKSClient.from_config","title":"<code>from_config(config: AuthConfig, *, http_client: httpx.AsyncClient | None = None, max_fetch_attempts: int = 2) -&gt; AsyncJWKSClient</code>  <code>classmethod</code>","text":"<p>Create an async JWKS client from configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AuthConfig</code> <p>Auth configuration with JWKS URL/cache/timeout settings.</p> required <code>http_client</code> <code>AsyncClient | None</code> <p>Optional externally managed client. If omitted, an internal client is created and owned by this instance.</p> <code>None</code> <code>max_fetch_attempts</code> <code>int</code> <p>Total fetch attempts for request failures. Must be <code>&gt;= 1</code>.</p> <code>2</code> <p>Returns:</p> Type Description <code>AsyncJWKSClient</code> <p>Configured <code>AsyncJWKSClient</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>max_fetch_attempts &lt; 1</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig\n&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://issuer.example/\",\n...     audience=\"https://api.example\",\n...     jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; client = AsyncJWKSClient.from_config(config)\n</code></pre> Source code in <code>oidc_jwt_verifier/async_jwks.py</code> <pre><code>@classmethod\ndef from_config(\n    cls,\n    config: AuthConfig,\n    *,\n    http_client: httpx.AsyncClient | None = None,\n    max_fetch_attempts: int = 2,\n) -&gt; AsyncJWKSClient:\n    \"\"\"Create an async JWKS client from configuration.\n\n    Args:\n        config: Auth configuration with JWKS URL/cache/timeout settings.\n        http_client: Optional externally managed client. If omitted,\n            an internal client is created and owned by this instance.\n        max_fetch_attempts: Total fetch attempts for request failures.\n            Must be ``&gt;= 1``.\n\n    Returns:\n        Configured ``AsyncJWKSClient``.\n\n    Raises:\n        ValueError: If ``max_fetch_attempts &lt; 1``.\n\n    Examples:\n        &gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig\n        &gt;&gt;&gt; config = AuthConfig(\n        ...     issuer=\"https://issuer.example/\",\n        ...     audience=\"https://api.example\",\n        ...     jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n        ... )\n        &gt;&gt;&gt; client = AsyncJWKSClient.from_config(config)\n    \"\"\"\n    if max_fetch_attempts &lt; 1:\n        raise ValueError(\"max_fetch_attempts must be &gt;= 1\")\n\n    owns_client = http_client is None\n    client = http_client or httpx.AsyncClient(timeout=config.jwks_timeout_s)\n    return cls(\n        _config=config,\n        _client=client,\n        _owns_client=owns_client,\n        _max_fetch_attempts=max_fetch_attempts,\n    )\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_jwks.AsyncJWKSClient.aclose","title":"<code>aclose() -&gt; None</code>  <code>async</code>","text":"<p>Close internal resources.</p> <p>Closes the underlying HTTP client only when this instance owns it.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # await client.aclose()\n</code></pre> Source code in <code>oidc_jwt_verifier/async_jwks.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Close internal resources.\n\n    Closes the underlying HTTP client only when this instance owns it.\n\n    Examples:\n        &gt;&gt;&gt; # await client.aclose()\n    \"\"\"\n    if self._owns_client:\n        await self._client.aclose()\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_jwks.AsyncJWKSClient.get_signing_key_from_jwt","title":"<code>get_signing_key_from_jwt(token: str | bytes) -&gt; PyJWK</code>  <code>async</code>","text":"<p>Resolve signing key for a JWT from configured JWKS.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | bytes</code> <p>Encoded JWT as <code>str</code> or ASCII-compatible <code>bytes</code>.</p> required <p>Returns:</p> Type Description <code>PyJWK</code> <p>Matching signing key.</p> <p>Raises:</p> Type Description <code>AuthError</code> <p>On key lookup/fetch/parsing failures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # signing_key = await client.get_signing_key_from_jwt(token)\n</code></pre> Source code in <code>oidc_jwt_verifier/async_jwks.py</code> <pre><code>async def get_signing_key_from_jwt(self, token: str | bytes) -&gt; PyJWK:\n    \"\"\"Resolve signing key for a JWT from configured JWKS.\n\n    Args:\n        token: Encoded JWT as ``str`` or ASCII-compatible ``bytes``.\n\n    Returns:\n        Matching signing key.\n\n    Raises:\n        AuthError: On key lookup/fetch/parsing failures.\n\n    Examples:\n        &gt;&gt;&gt; # signing_key = await client.get_signing_key_from_jwt(token)\n    \"\"\"\n    if isinstance(token, bytes):\n        try:\n            token_str = token.decode(\"utf-8\")\n        except UnicodeDecodeError as exc:\n            raise AuthError(\n                code=\"jwks_error\",\n                message=\"JWKS lookup failed\",\n                status_code=401,\n            ) from exc\n    else:\n        token_str = token\n\n    kid = self._extract_kid(token_str)\n    return await self.get_signing_key(kid)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_jwks.AsyncJWKSClient.get_signing_key","title":"<code>get_signing_key(kid: str) -&gt; PyJWK</code>  <code>async</code>","text":"<p>Resolve a signing key by <code>kid</code>.</p> <p>Performs lookup against cache first, then fetches/retries JWKS when needed, including one forced refresh attempt when <code>kid</code> is missing.</p> <p>Parameters:</p> Name Type Description Default <code>kid</code> <code>str</code> <p>JWT key identifier.</p> required <p>Returns:</p> Type Description <code>PyJWK</code> <p>Matching <code>PyJWK</code>.</p> <p>Raises:</p> Type Description <code>AuthError</code> <p>With <code>key_not_found</code> when no matching key exists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # signing_key = await client.get_signing_key(\"kid-123\")\n</code></pre> Source code in <code>oidc_jwt_verifier/async_jwks.py</code> <pre><code>async def get_signing_key(self, kid: str) -&gt; PyJWK:\n    \"\"\"Resolve a signing key by ``kid``.\n\n    Performs lookup against cache first, then fetches/retries JWKS when\n    needed, including one forced refresh attempt when ``kid`` is missing.\n\n    Args:\n        kid: JWT key identifier.\n\n    Returns:\n        Matching ``PyJWK``.\n\n    Raises:\n        AuthError: With ``key_not_found`` when no matching key exists.\n\n    Examples:\n        &gt;&gt;&gt; # signing_key = await client.get_signing_key(\"kid-123\")\n    \"\"\"\n    cached = await self._try_get_key_from_caches(kid)\n    if cached is not None:\n        return cached\n\n    key = await self._find_key_via_jwks(kid, refresh=False)\n    if key is not None:\n        return key\n\n    key = await self._find_key_via_jwks(kid, refresh=True)\n    if key is not None:\n        return key\n\n    raise AuthError(\n        code=\"key_not_found\",\n        message=\"No matching signing key\",\n        status_code=401,\n    )\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_verifier.AsyncJWTVerifier","title":"<code>AsyncJWTVerifier(config: AuthConfig, *, jwks_client: AsyncJWKSClient | None = None, http_client: httpx.AsyncClient | None = None)</code>","text":"<p>Stateful asynchronous JWT verifier for OIDC access tokens.</p> <p>This verifier preserves sync-path semantics while using asynchronous JWKS fetches and key lookups.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AuthConfig</code> <p>Authentication configuration.</p> required <code>jwks_client</code> <code>AsyncJWKSClient | None</code> <p>Optional externally managed async JWKS client.</p> <code>None</code> <code>http_client</code> <code>AsyncClient | None</code> <p>Optional externally managed <code>httpx.AsyncClient</code> used when creating an internal <code>AsyncJWKSClient</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig\n&gt;&gt;&gt; from oidc_jwt_verifier.async_verifier import AsyncJWTVerifier\n&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; verifier = AsyncJWTVerifier(config)\n</code></pre> <p>Initialize an async verifier.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AuthConfig</code> <p>Authentication configuration.</p> required <code>jwks_client</code> <code>AsyncJWKSClient | None</code> <p>Optional injected async JWKS client.</p> <code>None</code> <code>http_client</code> <code>AsyncClient | None</code> <p>Optional injected HTTP client for internally created async JWKS client.</p> <code>None</code> Source code in <code>oidc_jwt_verifier/async_verifier.py</code> <pre><code>def __init__(\n    self,\n    config: AuthConfig,\n    *,\n    jwks_client: AsyncJWKSClient | None = None,\n    http_client: httpx.AsyncClient | None = None,\n) -&gt; None:\n    \"\"\"Initialize an async verifier.\n\n    Args:\n        config: Authentication configuration.\n        jwks_client: Optional injected async JWKS client.\n        http_client: Optional injected HTTP client for internally created\n            async JWKS client.\n    \"\"\"\n    self._config = config\n    self._decoder = jwt.PyJWT(\n        options={\n            \"enforce_minimum_key_length\": config.enforce_minimum_key_length\n        }\n    )\n    self._jwks = jwks_client or AsyncJWKSClient.from_config(\n        config, http_client=http_client\n    )\n    self._owns_jwks = jwks_client is None\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_verifier.AsyncJWTVerifier.verify_access_token","title":"<code>verify_access_token(token: str) -&gt; dict[str, Any]</code>  <code>async</code>","text":"<p>Verify a JWT access token and return its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Encoded JWT string.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Decoded JWT payload.</p> <p>Raises:</p> Type Description <code>AuthError</code> <p>On authentication or authorization failure.</p> Source code in <code>oidc_jwt_verifier/async_verifier.py</code> <pre><code>async def verify_access_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Verify a JWT access token and return its claims.\n\n    Args:\n        token: Encoded JWT string.\n\n    Returns:\n        Decoded JWT payload.\n\n    Raises:\n        AuthError: On authentication or authorization failure.\n    \"\"\"\n    normalized = token.strip()\n    if not normalized:\n        raise AuthError(\n            code=\"missing_token\",\n            message=\"Missing access token\",\n            status_code=401,\n        )\n\n    _, algorithm = parse_and_validate_header(\n        normalized,\n        allowed_algorithms=self._config.allowed_algorithms,\n    )\n    signing_key = await self._jwks.get_signing_key_from_jwt(normalized)\n\n    payload = decode_and_validate_payload(\n        decoder=self._decoder,\n        token=normalized,\n        signing_key=signing_key,\n        algorithm=algorithm,\n        config=self._config,\n    )\n    enforce_authorization_claims(payload, config=self._config)\n    return payload\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_verifier.AsyncJWTVerifier.aclose","title":"<code>aclose() -&gt; None</code>  <code>async</code>","text":"<p>Close verifier-owned async resources.</p> <p>If the verifier created its own async JWKS client, this method closes that client and its owned HTTP resources.</p> Source code in <code>oidc_jwt_verifier/async_verifier.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Close verifier-owned async resources.\n\n    If the verifier created its own async JWKS client, this method closes\n    that client and its owned HTTP resources.\n    \"\"\"\n    if self._owns_jwks:\n        await self._jwks.aclose()\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_verifier.AsyncJWTVerifier.__aenter__","title":"<code>__aenter__() -&gt; AsyncJWTVerifier</code>  <code>async</code>","text":"<p>Enter async context manager for the verifier.</p> <p>Returns:</p> Type Description <code>AsyncJWTVerifier</code> <p>This verifier instance.</p> Source code in <code>oidc_jwt_verifier/async_verifier.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncJWTVerifier:\n    \"\"\"Enter async context manager for the verifier.\n\n    Returns:\n        This verifier instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.async_verifier.AsyncJWTVerifier.__aexit__","title":"<code>__aexit__(_exc_type: object, _exc: object, _tb: object) -&gt; None</code>  <code>async</code>","text":"<p>Exit async context manager and close owned resources.</p> Source code in <code>oidc_jwt_verifier/async_verifier.py</code> <pre><code>async def __aexit__(\n    self, _exc_type: object, _exc: object, _tb: object\n) -&gt; None:\n    \"\"\"Exit async context manager and close owned resources.\"\"\"\n    await self.aclose()\n</code></pre>"},{"location":"reference/#optional-fastapi-integration-api","title":"Optional FastAPI Integration API","text":"<p>Requires <code>pip install \"oidc-jwt-verifier[fastapi]\"</code>.</p> <ul> <li><code>oidc_jwt_verifier.integrations.fastapi.auth_error_to_http_exception</code></li> <li><code>oidc_jwt_verifier.integrations.fastapi.create_async_bearer_dependency</code></li> <li><code>oidc_jwt_verifier.integrations.fastapi.create_sync_bearer_dependency</code></li> </ul>"},{"location":"reference/#oidc_jwt_verifier.integrations.fastapi","title":"<code>fastapi</code>","text":"<p>FastAPI integration helpers.</p> <p>This module provides dependency factories that translate <code>AuthError</code> into <code>fastapi.HTTPException</code> while preserving RFC 6750 <code>WWW-Authenticate</code> headers.</p>"},{"location":"reference/#oidc_jwt_verifier.integrations.fastapi.auth_error_to_http_exception","title":"<code>auth_error_to_http_exception(error: AuthError, *, realm: str | None = None) -&gt; HTTPException</code>","text":"<p>Translate <code>AuthError</code> into <code>fastapi.HTTPException</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AuthError</code> <p>Auth error to convert.</p> required <code>realm</code> <code>str | None</code> <p>Optional RFC 6750 realm parameter.</p> <code>None</code> <p>Returns:</p> Type Description <code>HTTPException</code> <p>A FastAPI HTTP exception with status, detail and</p> <code>HTTPException</code> <p><code>WWW-Authenticate</code> header.</p> Source code in <code>oidc_jwt_verifier/integrations/fastapi.py</code> <pre><code>def auth_error_to_http_exception(\n    error: AuthError,\n    *,\n    realm: str | None = None,\n) -&gt; HTTPException:\n    \"\"\"Translate ``AuthError`` into ``fastapi.HTTPException``.\n\n    Args:\n        error: Auth error to convert.\n        realm: Optional RFC 6750 realm parameter.\n\n    Returns:\n        A FastAPI HTTP exception with status, detail and\n        ``WWW-Authenticate`` header.\n    \"\"\"\n    return HTTPException(\n        status_code=error.status_code,\n        detail=error.message,\n        headers={\n            \"WWW-Authenticate\": error.www_authenticate_header(realm=realm)\n        },\n    )\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.integrations.fastapi.create_async_bearer_dependency","title":"<code>create_async_bearer_dependency(verifier: AsyncJWTVerifier, *, realm: str | None = None, auto_error: bool = False) -&gt; Callable[[HTTPAuthorizationCredentials | None], Awaitable[dict[str, Any]]]</code>","text":"<p>Create a FastAPI dependency for <code>AsyncJWTVerifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>AsyncJWTVerifier</code> <p>Async verifier instance.</p> required <code>realm</code> <code>str | None</code> <p>Optional RFC 6750 realm.</p> <code>None</code> <code>auto_error</code> <code>bool</code> <p>Passed to <code>HTTPBearer</code>. Keep this <code>False</code> to let the library produce uniform <code>AuthError</code> mapping.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[HTTPAuthorizationCredentials | None], Awaitable[dict[str, Any]]]</code> <p>A dependency callable returning decoded claims on success.</p> Source code in <code>oidc_jwt_verifier/integrations/fastapi.py</code> <pre><code>def create_async_bearer_dependency(\n    verifier: AsyncJWTVerifier,\n    *,\n    realm: str | None = None,\n    auto_error: bool = False,\n) -&gt; Callable[[HTTPAuthorizationCredentials | None], Awaitable[dict[str, Any]]]:\n    \"\"\"Create a FastAPI dependency for ``AsyncJWTVerifier``.\n\n    Args:\n        verifier: Async verifier instance.\n        realm: Optional RFC 6750 realm.\n        auto_error: Passed to ``HTTPBearer``. Keep this ``False`` to let the\n            library produce uniform ``AuthError`` mapping.\n\n    Returns:\n        A dependency callable returning decoded claims on success.\n    \"\"\"\n    security = HTTPBearer(auto_error=auto_error)\n\n    async def dependency(\n        credentials: HTTPAuthorizationCredentials | None = Depends(security),  # noqa: B008\n    ) -&gt; dict[str, Any]:\n        \"\"\"Resolve and verify bearer token for one request.\n\n        Args:\n            credentials: FastAPI bearer credentials.\n\n        Returns:\n            Decoded token claims.\n\n        Raises:\n            HTTPException: When authentication/authorization fails.\n        \"\"\"\n        token = credentials.credentials if credentials is not None else \"\"\n        try:\n            return await verifier.verify_access_token(token)\n        except AuthError as exc:\n            raise auth_error_to_http_exception(exc, realm=realm) from exc\n\n    return dependency\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.integrations.fastapi.create_sync_bearer_dependency","title":"<code>create_sync_bearer_dependency(verifier: JWTVerifier, *, realm: str | None = None, offload_to_threadpool: bool = True, auto_error: bool = False) -&gt; Callable[[HTTPAuthorizationCredentials | None], Awaitable[dict[str, Any]]]</code>","text":"<p>Create a FastAPI dependency for sync <code>JWTVerifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>JWTVerifier</code> <p>Sync verifier instance.</p> required <code>realm</code> <code>str | None</code> <p>Optional RFC 6750 realm.</p> <code>None</code> <code>offload_to_threadpool</code> <code>bool</code> <p>Whether to run sync verification in <code>run_in_threadpool</code>. Set to <code>False</code> only when keys are already cached or otherwise guaranteed local; if JWKS must be fetched over HTTP, sync I/O will block the event loop.</p> <code>True</code> <code>auto_error</code> <code>bool</code> <p>Passed to <code>HTTPBearer</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[HTTPAuthorizationCredentials | None], Awaitable[dict[str, Any]]]</code> <p>A dependency callable returning decoded claims on success.</p> Source code in <code>oidc_jwt_verifier/integrations/fastapi.py</code> <pre><code>def create_sync_bearer_dependency(\n    verifier: JWTVerifier,\n    *,\n    realm: str | None = None,\n    offload_to_threadpool: bool = True,\n    auto_error: bool = False,\n) -&gt; Callable[[HTTPAuthorizationCredentials | None], Awaitable[dict[str, Any]]]:\n    \"\"\"Create a FastAPI dependency for sync ``JWTVerifier``.\n\n    Args:\n        verifier: Sync verifier instance.\n        realm: Optional RFC 6750 realm.\n        offload_to_threadpool: Whether to run sync verification in\n            ``run_in_threadpool``. Set to ``False`` only when keys are already\n            cached or otherwise guaranteed local; if JWKS must be fetched over\n            HTTP, sync I/O will block the event loop.\n        auto_error: Passed to ``HTTPBearer``.\n\n    Returns:\n        A dependency callable returning decoded claims on success.\n    \"\"\"\n    security = HTTPBearer(auto_error=auto_error)\n\n    async def dependency(\n        credentials: HTTPAuthorizationCredentials | None = Depends(security),  # noqa: B008\n    ) -&gt; dict[str, Any]:\n        \"\"\"Resolve and verify bearer token for one request.\n\n        Args:\n            credentials: FastAPI bearer credentials.\n\n        Returns:\n            Decoded token claims.\n\n        Raises:\n            HTTPException: When authentication/authorization fails.\n        \"\"\"\n        token = credentials.credentials if credentials is not None else \"\"\n        try:\n            if offload_to_threadpool:\n                return cast(\n                    \"dict[str, Any]\",\n                    await run_in_threadpool(\n                        verifier.verify_access_token, token\n                    ),\n                )\n            return verifier.verify_access_token(token)\n        except AuthError as exc:\n            raise auth_error_to_http_exception(exc, realm=realm) from exc\n\n    return dependency\n</code></pre>"},{"location":"reference/#optional-starlette-integration-api","title":"Optional Starlette Integration API","text":"<p>Requires <code>pip install \"oidc-jwt-verifier[starlette]\"</code>.</p> <ul> <li><code>oidc_jwt_verifier.integrations.starlette.BearerAuthMiddleware</code></li> <li><code>oidc_jwt_verifier.integrations.starlette.verify_request_bearer_token</code></li> <li><code>oidc_jwt_verifier.integrations.starlette.auth_error_to_response</code></li> </ul>"},{"location":"reference/#oidc_jwt_verifier.integrations.starlette","title":"<code>starlette</code>","text":"<p>Starlette integration helpers.</p> <p>This module offers middleware and helper functions to apply verifier logic in Starlette applications while preserving RFC 6750 response semantics.</p> <p>Returns:</p> Type Description <p>None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier.integrations.starlette import (\n...     BearerAuthMiddleware,\n... )\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.integrations.starlette.BearerAuthMiddleware","title":"<code>BearerAuthMiddleware(app: ASGIApp, *, verifier: JWTVerifier | AsyncJWTVerifier, realm: str | None = None, exempt_paths: set[str] | None = None, claims_state_key: str = 'auth_claims')</code>","text":"<p>Starlette middleware that verifies bearer access tokens.</p> <p>Valid claims are stored in <code>request.state</code> under <code>claims_state_key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>ASGIApp</code> <p>Downstream ASGI app.</p> required <code>verifier</code> <code>JWTVerifier | AsyncJWTVerifier</code> <p>Sync or async verifier.</p> required <code>realm</code> <code>str | None</code> <p>Optional realm for RFC 6750 header generation.</p> <code>None</code> <code>exempt_paths</code> <code>set[str] | None</code> <p>Paths to skip authentication for.</p> <code>None</code> <code>claims_state_key</code> <code>str</code> <p>Key used in <code>request.state</code> for decoded claims.</p> <code>'auth_claims'</code> <p>Returns:</p> Type Description <p>None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from starlette.applications import Starlette\n&gt;&gt;&gt; app = Starlette()\n&gt;&gt;&gt; _ = BearerAuthMiddleware(app, verifier=verifier)\n</code></pre> <p>Initialize middleware configuration.</p> Source code in <code>oidc_jwt_verifier/integrations/starlette.py</code> <pre><code>def __init__(\n    self,\n    app: ASGIApp,\n    *,\n    verifier: JWTVerifier | AsyncJWTVerifier,\n    realm: str | None = None,\n    exempt_paths: set[str] | None = None,\n    claims_state_key: str = \"auth_claims\",\n) -&gt; None:\n    \"\"\"Initialize middleware configuration.\"\"\"\n    self._app = app\n    self._verifier = verifier\n    self._realm = realm\n    self._exempt_paths = exempt_paths or set()\n    self._claims_state_key = claims_state_key\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.integrations.starlette.BearerAuthMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Process request authentication.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>Scope</code> <p>ASGI scope.</p> required <code>receive</code> <code>Receive</code> <p>ASGI receive callable.</p> required <code>send</code> <code>Send</code> <p>ASGI send callable.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Invoked by Starlette's ASGI runtime, not called directly.\n&gt;&gt;&gt; # await middleware(scope, receive, send)\n</code></pre> Source code in <code>oidc_jwt_verifier/integrations/starlette.py</code> <pre><code>async def __call__(\n    self, scope: Scope, receive: Receive, send: Send\n) -&gt; None:\n    \"\"\"Process request authentication.\n\n    Args:\n        scope: ASGI scope.\n        receive: ASGI receive callable.\n        send: ASGI send callable.\n\n    Returns:\n        None.\n\n    Raises:\n        None. ``AuthError`` is handled and converted into an RFC 6750 response.\n\n    Examples:\n        &gt;&gt;&gt; # Invoked by Starlette's ASGI runtime, not called directly.\n        &gt;&gt;&gt; # await middleware(scope, receive, send)\n    \"\"\"\n    if scope.get(\"type\") != \"http\":\n        await self._app(scope, receive, send)\n        return\n\n    if scope.get(\"path\") in self._exempt_paths:\n        await self._app(scope, receive, send)\n        return\n\n    request = Request(scope, receive=receive)\n    try:\n        claims = await verify_request_bearer_token(\n            request, verifier=self._verifier\n        )\n    except AuthError as exc:\n        response = auth_error_to_response(exc, realm=self._realm)\n        await response(scope, receive, send)\n        return\n\n    state = scope.setdefault(\"state\", {})\n    if isinstance(state, dict):\n        state[self._claims_state_key] = claims\n\n    await self._app(scope, receive, send)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.integrations.starlette.auth_error_to_response","title":"<code>auth_error_to_response(error: AuthError, *, realm: str | None = None) -&gt; JSONResponse</code>","text":"<p>Convert <code>AuthError</code> into a Starlette JSON response.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AuthError</code> <p>Auth error to convert.</p> required <code>realm</code> <code>str | None</code> <p>Optional realm for <code>WWW-Authenticate</code> header.</p> <code>None</code> <p>Returns:</p> Type Description <code>JSONResponse</code> <p>JSON response with correct status and RFC 6750 header.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier.errors import AuthError\n&gt;&gt;&gt; error = AuthError(code=\"invalid_token\", message=\"bad token\")\n&gt;&gt;&gt; response = auth_error_to_response(error)\n&gt;&gt;&gt; response.status_code\n401\n</code></pre> Source code in <code>oidc_jwt_verifier/integrations/starlette.py</code> <pre><code>def auth_error_to_response(\n    error: AuthError,\n    *,\n    realm: str | None = None,\n) -&gt; JSONResponse:\n    \"\"\"Convert ``AuthError`` into a Starlette JSON response.\n\n    Args:\n        error: Auth error to convert.\n        realm: Optional realm for ``WWW-Authenticate`` header.\n\n    Returns:\n        JSON response with correct status and RFC 6750 header.\n\n    Raises:\n        None.\n\n    Examples:\n        &gt;&gt;&gt; from oidc_jwt_verifier.errors import AuthError\n        &gt;&gt;&gt; error = AuthError(code=\"invalid_token\", message=\"bad token\")\n        &gt;&gt;&gt; response = auth_error_to_response(error)\n        &gt;&gt;&gt; response.status_code\n        401\n    \"\"\"\n    return JSONResponse(\n        {\"detail\": error.message, \"code\": error.code},\n        status_code=error.status_code,\n        headers={\n            \"WWW-Authenticate\": error.www_authenticate_header(realm=realm)\n        },\n    )\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.integrations.starlette.extract_bearer_token","title":"<code>extract_bearer_token(authorization_header: str | None) -&gt; str</code>","text":"<p>Extract a bearer token from <code>Authorization</code> header value.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_header</code> <code>str | None</code> <p>Raw header value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Bearer token string, or empty string when missing/invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extract_bearer_token(\"Bearer abc.def.ghi\")\n'abc.def.ghi'\n&gt;&gt;&gt; extract_bearer_token(\"Basic abc\")\n''\n</code></pre> Source code in <code>oidc_jwt_verifier/integrations/starlette.py</code> <pre><code>def extract_bearer_token(authorization_header: str | None) -&gt; str:\n    \"\"\"Extract a bearer token from ``Authorization`` header value.\n\n    Args:\n        authorization_header: Raw header value.\n\n    Returns:\n        Bearer token string, or empty string when missing/invalid.\n\n    Raises:\n        None.\n\n    Examples:\n        &gt;&gt;&gt; extract_bearer_token(\"Bearer abc.def.ghi\")\n        'abc.def.ghi'\n        &gt;&gt;&gt; extract_bearer_token(\"Basic abc\")\n        ''\n    \"\"\"\n    if authorization_header is None:\n        return \"\"\n    parts = authorization_header.split(\" \", 1)\n    if len(parts) != 2 or parts[0].lower() != \"bearer\":\n        return \"\"\n    return parts[1].strip()\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.integrations.starlette.verify_request_bearer_token","title":"<code>verify_request_bearer_token(request: Request, *, verifier: JWTVerifier | AsyncJWTVerifier) -&gt; dict[str, Any]</code>  <code>async</code>","text":"<p>Verify bearer token from a Starlette request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>Incoming request.</p> required <code>verifier</code> <code>JWTVerifier | AsyncJWTVerifier</code> <p>Sync or async verifier instance.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Decoded JWT claims.</p> <p>Raises:</p> Type Description <code>AuthError</code> <p>On authentication/authorization failure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Usually called from middleware with a Starlette ``Request``.\n&gt;&gt;&gt; # claims = await verify_request_bearer_token(request, verifier=verifier)\n</code></pre> Source code in <code>oidc_jwt_verifier/integrations/starlette.py</code> <pre><code>async def verify_request_bearer_token(\n    request: Request,\n    *,\n    verifier: JWTVerifier | AsyncJWTVerifier,\n) -&gt; dict[str, Any]:\n    \"\"\"Verify bearer token from a Starlette request.\n\n    Args:\n        request: Incoming request.\n        verifier: Sync or async verifier instance.\n\n    Returns:\n        Decoded JWT claims.\n\n    Raises:\n        AuthError: On authentication/authorization failure.\n\n    Examples:\n        &gt;&gt;&gt; # Usually called from middleware with a Starlette ``Request``.\n        &gt;&gt;&gt; # claims = await verify_request_bearer_token(request, verifier=verifier)\n    \"\"\"\n    token = extract_bearer_token(request.headers.get(\"Authorization\"))\n    if isinstance(verifier, JWTVerifier):\n        return cast(\n            \"dict[str, Any]\",\n            await run_in_threadpool(verifier.verify_access_token, token),\n        )\n    return await verifier.verify_access_token(token)\n</code></pre>"},{"location":"security/","title":"Security Model","text":"<p>The verifier is designed to fail closed. If any validation step fails, the token is rejected.</p>"},{"location":"security/#hardening-defaults","title":"Hardening Defaults","text":"<ul> <li>Rejects tokens with <code>alg=none</code>.</li> <li>Enforces explicit algorithm allowlist from <code>AuthConfig.allowed_algs</code>.</li> <li>Rejects tokens containing <code>jku</code>, <code>x5u</code>, or <code>crit</code> headers.</li> <li>Requires <code>kid</code> for JWKS key lookup.</li> <li>Verifies signature, issuer, audience, and expiration.</li> <li>Verifies <code>nbf</code> when present.</li> <li>Enforces minimum key length by default (<code>enforce_minimum_key_length=True</code>).</li> </ul>"},{"location":"security/#jwks-trust-boundary","title":"JWKS Trust Boundary","text":"<ul> <li>Keys are fetched only from <code>AuthConfig.jwks_url</code>.</li> <li>The JWKS URL is never derived from token content.</li> <li>JWKS fetch and parse failures return authentication errors (<code>401</code>).</li> </ul>"},{"location":"security/#authorization-enforcement","title":"Authorization Enforcement","text":"<ul> <li><code>required_scopes</code> and <code>required_permissions</code> are enforced after successful authentication.</li> <li>Authorization failures return <code>403</code>.</li> <li><code>WWW-Authenticate</code> includes RFC 6750 semantics.</li> </ul>"},{"location":"security/#operational-guidance","title":"Operational Guidance","text":"<ul> <li>Do not log raw bearer tokens.</li> <li>Log <code>AuthError.code</code> and <code>AuthError.status_code</code> for safe diagnostics.</li> <li>Reuse verifier instances to avoid unnecessary network and cache churn.</li> <li>Keep algorithm allowlists tight and explicit.</li> </ul>"},{"location":"security/#standards-and-references","title":"Standards and References","text":"<ul> <li>RFC 8725: JWT Best Current Practices</li> <li>RFC 7519: JSON Web Token (JWT)</li> <li>RFC 6750: OAuth 2.0 Bearer Token Usage</li> <li>PyJWT Documentation</li> </ul>"},{"location":"architecture/adr/ADR-async-capabilities-strategy/","title":"ADR: Async Capabilities Strategy","text":"<ul> <li>Status: Accepted</li> <li>Date: 2026-02-12</li> <li>Owners: <code>oidc-jwt-verifier</code> maintainers</li> </ul>"},{"location":"architecture/adr/ADR-async-capabilities-strategy/#context","title":"Context","text":"<p>The package originally provided a sync verification path only. ASGI applications need non-blocking JWT verification and framework-ready integration.</p> <p>Constraints:</p> <ul> <li>Keep sync APIs backward compatible.</li> <li>Preserve fail-closed JWT/OIDC behavior.</li> <li>Support FastAPI and Starlette with first-party helpers.</li> <li>Keep optional dependencies out of the base install.</li> </ul>"},{"location":"architecture/adr/ADR-async-capabilities-strategy/#options-considered","title":"Options Considered","text":"<ol> <li>Sync core only, async adapters via threadpool offload.</li> <li>Full parallel async stack with duplicated policy logic.</li> <li>Shared policy core with separate sync and async transports.</li> <li>Async-first rewrite with sync wrappers.</li> <li>Refined shared-policy architecture with dedicated framework helpers.</li> </ol>"},{"location":"architecture/adr/ADR-async-capabilities-strategy/#decision-framework","title":"Decision Framework","text":"Criterion Weight Solution leverage 35% Application value 30% Maintenance and cognitive load 25% Architectural adaptability 10% Option Solution leverage Application value Maintenance/cognitive load Adaptability Weighted total 1. Threadpool adapters only 8.5 7.6 8.8 6.8 8.08 2. Parallel async stack 8.7 8.9 7.1 8.2 8.26 3. Shared-policy core 9.5 9.4 9.0 9.2 9.30 4. Async-first rewrite 7.0 8.4 6.3 8.8 7.37 5. Refined shared-policy + helpers (chosen) 9.6 9.5 9.1 9.4 9.41"},{"location":"architecture/adr/ADR-async-capabilities-strategy/#decision","title":"Decision","text":"<p>Adopt option 5.</p> <p>Implementation shape:</p> <ul> <li>Keep sync API: <code>AuthConfig</code>, <code>AuthError</code>, <code>JWKSClient</code>, <code>JWTVerifier</code>.</li> <li>Add async API: <code>AsyncJWKSClient</code>, <code>AsyncJWTVerifier</code>.</li> <li>Centralize policy logic in internal <code>_policy.py</code>.</li> <li>Provide integration helpers for FastAPI and Starlette.</li> <li>Publish optional extras: <code>async</code>, <code>fastapi</code>, <code>starlette</code>.</li> </ul>"},{"location":"architecture/adr/ADR-async-capabilities-strategy/#rationale","title":"Rationale","text":"<ul> <li>Shared policy avoids behavior drift between sync and async paths.</li> <li>Existing sync consumers do not need migration.</li> <li>Async users get native non-blocking JWKS fetch and verification.</li> <li>Framework users get consistent RFC 6750 error handling out of the box.</li> </ul>"},{"location":"architecture/adr/ADR-async-capabilities-strategy/#consequences","title":"Consequences","text":"<p>Positive:</p> <ul> <li>Policy parity across runtime models</li> <li>Better ASGI performance profile than forced threadpool offload</li> <li>Clear optional-dependency boundaries</li> </ul> <p>Costs:</p> <ul> <li>Larger API and test matrix</li> <li>More packaging combinations to validate</li> <li>Async lifecycle ownership needs explicit documentation</li> </ul>"},{"location":"architecture/adr/ADR-async-capabilities-strategy/#rejected-alternatives","title":"Rejected Alternatives","text":"<ul> <li>Threadpool-only adapters: no native async fetch path.</li> <li>Duplicated policy in sync/async code: long-term drift risk.</li> <li>Async-first rewrite: unnecessary migration cost for sync users.</li> </ul>"},{"location":"architecture/adr/ADR-async-capabilities-strategy/#follow-up","title":"Follow-up","text":"<ul> <li>Keep sync/async parity tests mandatory for policy changes.</li> <li>Keep integration tests for FastAPI and Starlette behavior.</li> <li>Benchmark async path and sync-threadpool fallback under concurrent load.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/","title":"SPEC: Async Capabilities for FastAPI and Starlette","text":"<ul> <li>Status: Implemented</li> <li>Date: 2026-02-12</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#goals","title":"Goals","text":"<ul> <li>Provide native async JWT verification.</li> <li>Keep existing sync API behavior intact.</li> <li>Provide first-party FastAPI and Starlette helpers.</li> <li>Maintain strict fail-closed security defaults.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#non-goals","title":"Non-goals","text":"<ul> <li>Removing sync APIs.</li> <li>OIDC discovery or dynamic endpoint derivation from token data.</li> <li>Built-in telemetry backend integrations.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#public-api-contract","title":"Public API Contract","text":""},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#sync","title":"Sync","text":"<ul> <li><code>JWTVerifier.verify_access_token(token: str) -&gt; dict[str, Any]</code></li> <li><code>JWKSClient.get_signing_key_from_jwt(token: str | bytes) -&gt; PyJWK</code></li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#async","title":"Async","text":"<ul> <li><code>AsyncJWTVerifier.verify_access_token(token: str) -&gt; dict[str, Any]</code></li> <li><code>AsyncJWTVerifier.aclose() -&gt; None</code></li> <li><code>AsyncJWKSClient.get_signing_key_from_jwt(token: str | bytes) -&gt; PyJWK</code></li> <li><code>AsyncJWKSClient.aclose() -&gt; None</code></li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#integrations","title":"Integrations","text":"<p>FastAPI (<code>oidc_jwt_verifier.integrations.fastapi</code>):</p> <ul> <li><code>create_async_bearer_dependency(...)</code></li> <li><code>create_sync_bearer_dependency(...)</code></li> <li><code>auth_error_to_http_exception(...)</code></li> </ul> <p>Starlette (<code>oidc_jwt_verifier.integrations.starlette</code>):</p> <ul> <li><code>BearerAuthMiddleware</code></li> <li><code>verify_request_bearer_token(...)</code></li> <li><code>auth_error_to_response(...)</code></li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#packaging-strategy","title":"Packaging Strategy","text":"<p>Optional extras:</p> <ul> <li><code>async</code>: <code>httpx</code>, <code>anyio</code></li> <li><code>fastapi</code>: <code>fastapi</code> plus async dependencies</li> <li><code>starlette</code>: <code>starlette</code> plus async dependencies</li> </ul> <p>Base install remains sync-only.</p> <p>Import boundaries:</p> <ul> <li>Root import works without async dependencies.</li> <li>Async modules require async dependencies.</li> <li>Framework integration modules require framework dependencies.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#shared-policy-model","title":"Shared Policy Model","text":"<p><code>oidc_jwt_verifier._policy</code> defines shared behavior for sync and async verifiers:</p> <ul> <li>Header checks (<code>jku</code>, <code>x5u</code>, <code>crit</code>, <code>alg</code>, <code>kid</code>)</li> <li>Decode options and claim verification loop</li> <li>Decode exception to <code>AuthError</code> mapping</li> <li>Scope and permission enforcement</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#lifecycle-rules","title":"Lifecycle Rules","text":""},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#asyncjwksclient","title":"AsyncJWKSClient","text":"<ul> <li>Owns and closes internal <code>httpx.AsyncClient</code> when created internally.</li> <li>Does not close externally injected <code>httpx.AsyncClient</code>.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#asyncjwtverifier","title":"AsyncJWTVerifier","text":"<ul> <li>Closes internal async JWKS client only when it created that client.</li> <li>Does not close externally injected JWKS client.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#cache-and-fetch-behavior","title":"Cache and Fetch Behavior","text":"<ul> <li>JWKS document cache with TTL (<code>jwks_cache_ttl_s</code>).</li> <li>Key cache by <code>kid</code> with max size (<code>jwks_max_cached_keys</code>).</li> <li>On missing <code>kid</code>, perform normal lookup, then one forced JWKS refresh, then fail.</li> <li>Async fetch supports configurable retry attempts (<code>max_fetch_attempts</code>, default <code>2</code>).</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#error-semantics","title":"Error Semantics","text":"<p>Sync and async paths emit the same <code>AuthError</code> taxonomy and status semantics.</p> <ul> <li>Authentication failures return <code>401</code>.</li> <li>Authorization failures return <code>403</code>.</li> <li><code>WWW-Authenticate</code> values are produced by <code>AuthError.www_authenticate_header()</code>.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#security-constraints","title":"Security Constraints","text":"<ul> <li>Reject <code>alg=none</code>.</li> <li>Enforce configured algorithm allowlist.</li> <li>Reject <code>jku</code>, <code>x5u</code>, and <code>crit</code> headers.</li> <li>Require <code>kid</code> for key lookup.</li> <li>Never derive JWKS source from token headers.</li> <li>Fail closed on parse, fetch, decode, and claim failures.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#performance-expectations","title":"Performance Expectations","text":"<ul> <li>Async path should be preferred for async frameworks to avoid blocking behavior.</li> <li>Sync verifier remains valid in async frameworks through threadpool helpers when migration is not immediate.</li> <li>Performance verification should compare native async path vs sync-threadpool fallback under concurrent load.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#compatibility-and-versioning","title":"Compatibility and Versioning","text":"<ul> <li>Sync API remains backward compatible.</li> <li>Async and framework APIs are additive.</li> <li>Release impact is minor-version additive behavior.</li> </ul>"},{"location":"architecture/spec/SPEC-async-capabilities-fastapi-starlette/#references","title":"References","text":"<ul> <li>https://fastapi.tiangolo.com/async/</li> <li>https://fastapi.tiangolo.com/tutorial/dependencies/</li> <li>https://www.starlette.io/threadpool/</li> <li>https://www.starlette.io/</li> <li>https://anyio.readthedocs.io/en/stable/</li> <li>https://pyjwt.readthedocs.io/en/stable/</li> <li>https://pyjwt.readthedocs.io/en/stable/api.html</li> <li>https://packaging.python.org/en/latest/specifications/declaring-project-metadata/</li> <li>https://docs.astral.sh/uv/</li> <li>https://datatracker.ietf.org/doc/html/rfc8725</li> <li>https://datatracker.ietf.org/doc/html/rfc6750</li> <li>https://www.rfc-editor.org/rfc/rfc7519</li> </ul>"},{"location":"integrations/fastapi/","title":"FastAPI Integration","text":"<p>Install:</p> <pre><code>pip install \"oidc-jwt-verifier[fastapi]\"\n</code></pre>"},{"location":"integrations/fastapi/#async-dependency-recommended","title":"Async Dependency (Recommended)","text":"<p>Use <code>create_async_bearer_dependency()</code> with <code>AsyncJWTVerifier</code> for native async verification.</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom fastapi import Depends, FastAPI\n\nfrom oidc_jwt_verifier import AuthConfig\nfrom oidc_jwt_verifier.async_verifier import AsyncJWTVerifier\nfrom oidc_jwt_verifier.integrations.fastapi import create_async_bearer_dependency\n\nverifier = AsyncJWTVerifier(\n    AuthConfig(\n        issuer=\"https://issuer.example/\",\n        audience=\"https://api.example\",\n        jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n    )\n)\nauth = create_async_bearer_dependency(verifier, realm=\"api\")\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    yield\n    await verifier.aclose()\n\napp = FastAPI(lifespan=lifespan)\n\n@app.get(\"/protected\")\nasync def protected(claims: dict = Depends(auth)):\n    return {\"sub\": claims.get(\"sub\")}\n</code></pre>"},{"location":"integrations/fastapi/#sync-dependency","title":"Sync Dependency","text":"<p>If your app still uses <code>JWTVerifier</code>, use <code>create_sync_bearer_dependency()</code>.</p> <pre><code>from fastapi import Depends, FastAPI\n\nfrom oidc_jwt_verifier import AuthConfig, JWTVerifier\nfrom oidc_jwt_verifier.integrations.fastapi import create_sync_bearer_dependency\n\napp = FastAPI()\nverifier = JWTVerifier(\n    AuthConfig(\n        issuer=\"https://issuer.example/\",\n        audience=\"https://api.example\",\n        jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n    )\n)\nauth = create_sync_bearer_dependency(\n    verifier,\n    realm=\"api\",\n    offload_to_threadpool=True,\n)\n\n@app.get(\"/protected\")\nasync def protected(claims: dict = Depends(auth)):\n    return {\"sub\": claims.get(\"sub\")}\n</code></pre>"},{"location":"integrations/fastapi/#error-behavior","title":"Error Behavior","text":"<p>Helpers convert <code>AuthError</code> to <code>fastapi.HTTPException</code> and preserve RFC 6750 response headers.</p> <ul> <li>Status code from <code>AuthError.status_code</code></li> <li>Detail from <code>AuthError.message</code></li> <li><code>WWW-Authenticate</code> header from <code>AuthError.www_authenticate_header()</code></li> </ul>"},{"location":"integrations/fastapi/#notes","title":"Notes","text":"<ul> <li>Reuse verifier instances across requests.</li> <li>Keep <code>HTTPBearer(auto_error=False)</code> behavior from helper defaults for uniform error mapping.</li> <li>Close <code>AsyncJWTVerifier</code> at shutdown when it owns its HTTP resources.</li> </ul>"},{"location":"integrations/starlette/","title":"Starlette Integration","text":"<p>Install:</p> <pre><code>pip install \"oidc-jwt-verifier[starlette]\"\n</code></pre>"},{"location":"integrations/starlette/#middleware-pattern-recommended","title":"Middleware Pattern (Recommended)","text":"<p><code>BearerAuthMiddleware</code> verifies bearer tokens for each HTTP request. On success, decoded claims are stored in <code>request.state.auth_claims</code> by default.</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom oidc_jwt_verifier import AuthConfig\nfrom oidc_jwt_verifier.async_verifier import AsyncJWTVerifier\nfrom oidc_jwt_verifier.integrations.starlette import BearerAuthMiddleware\n\nverifier = AsyncJWTVerifier(\n    AuthConfig(\n        issuer=\"https://issuer.example/\",\n        audience=\"https://api.example\",\n        jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n    )\n)\n\nasync def protected(request: Request) -&gt; JSONResponse:\n    claims = request.state.auth_claims\n    return JSONResponse({\"sub\": claims.get(\"sub\")})\n\n@asynccontextmanager\nasync def lifespan(_: Starlette):\n    yield\n    await verifier.aclose()\n\napp = Starlette(routes=[Route(\"/protected\", protected)], lifespan=lifespan)\napp.add_middleware(\n    BearerAuthMiddleware,\n    verifier=verifier,\n    realm=\"api\",\n    exempt_paths={\"/healthz\"},\n)\n</code></pre>"},{"location":"integrations/starlette/#manual-verification-in-endpoints","title":"Manual Verification in Endpoints","text":"<p>If you do not want middleware, use <code>verify_request_bearer_token()</code> directly.</p> <pre><code>from starlette.requests import Request\nfrom starlette.responses import JSONResponse\n\nfrom oidc_jwt_verifier import AuthError\nfrom oidc_jwt_verifier.integrations.starlette import (\n    auth_error_to_response,\n    verify_request_bearer_token,\n)\n\nasync def protected(request: Request) -&gt; JSONResponse:\n    try:\n        claims = await verify_request_bearer_token(request, verifier=verifier)\n    except AuthError as exc:\n        return auth_error_to_response(exc, realm=\"api\")\n\n    return JSONResponse({\"sub\": claims.get(\"sub\")})\n</code></pre>"},{"location":"integrations/starlette/#sync-verifier-support","title":"Sync Verifier Support","text":"<p><code>BearerAuthMiddleware</code> and <code>verify_request_bearer_token()</code> accept either:</p> <ul> <li><code>AsyncJWTVerifier</code> (native async verification)</li> <li><code>JWTVerifier</code> (automatically offloaded with <code>starlette.concurrency.run_in_threadpool</code>)</li> </ul>"},{"location":"integrations/starlette/#error-behavior","title":"Error Behavior","text":"<p>When verification fails, helper responses include:</p> <ul> <li>JSON body with <code>detail</code> and <code>code</code></li> <li>HTTP status from <code>AuthError.status_code</code></li> <li>RFC 6750 <code>WWW-Authenticate</code> header from <code>AuthError.www_authenticate_header()</code></li> </ul>"},{"location":"integrations/starlette/#middleware-options","title":"Middleware Options","text":"<p><code>BearerAuthMiddleware</code> options:</p> <ul> <li><code>realm</code>: optional RFC 6750 realm</li> <li><code>exempt_paths</code>: exact path matches that skip authentication</li> <li><code>claims_state_key</code>: request state key for decoded claims (default: <code>\"auth_claims\"</code>)</li> </ul>"},{"location":"usage/async/","title":"Usage: Async","text":""},{"location":"usage/async/#when-to-use-the-async-verifier","title":"When to Use the Async Verifier","text":"<p>Use <code>AsyncJWTVerifier</code> in ASGI applications and any async code path where blocking network I/O should be avoided.</p>"},{"location":"usage/async/#basic-pattern","title":"Basic Pattern","text":"<pre><code>from oidc_jwt_verifier import AuthConfig, AuthError\nfrom oidc_jwt_verifier.async_verifier import AsyncJWTVerifier\n\nconfig = AuthConfig(\n    issuer=\"https://issuer.example/\",\n    audience=\"https://api.example\",\n    jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n)\n\nasync with AsyncJWTVerifier(config) as verifier:\n    try:\n        claims = await verifier.verify_access_token(token)\n    except AuthError as error:\n        status = error.status_code\n</code></pre>"},{"location":"usage/async/#lifecycle-and-resource-ownership","title":"Lifecycle and Resource Ownership","text":"<p><code>AsyncJWTVerifier</code> can own its network resources or use externally-managed resources.</p>"},{"location":"usage/async/#verifier-owned-resources","title":"Verifier-owned resources","text":"<ul> <li>Construct with <code>AsyncJWTVerifier(config)</code>.</li> <li>Call <code>await verifier.aclose()</code> when shutting down.</li> <li>Using <code>async with</code> is the safest option.</li> </ul>"},{"location":"usage/async/#externally-managed-http-client","title":"Externally-managed HTTP client","text":"<pre><code>import httpx\nfrom oidc_jwt_verifier import AuthConfig\nfrom oidc_jwt_verifier.async_verifier import AsyncJWTVerifier\n\nhttp_client = httpx.AsyncClient(timeout=3.0)\nverifier = AsyncJWTVerifier(\n    AuthConfig(\n        issuer=\"https://issuer.example/\",\n        audience=\"https://api.example\",\n        jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n    ),\n    http_client=http_client,\n)\n</code></pre> <p>In this mode, <code>verifier.aclose()</code> does not close your injected <code>http_client</code>.</p>"},{"location":"usage/async/#async-jwks-client-advanced","title":"Async JWKS Client (Advanced)","text":"<p>Most applications only need <code>AsyncJWTVerifier</code>. If you need direct key resolution control, use <code>AsyncJWKSClient</code>:</p> <pre><code>from oidc_jwt_verifier import AuthConfig\nfrom oidc_jwt_verifier.async_jwks import AsyncJWKSClient\n\nclient = AsyncJWKSClient.from_config(\n    AuthConfig(\n        issuer=\"https://issuer.example/\",\n        audience=\"https://api.example\",\n        jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n    )\n)\n</code></pre>"},{"location":"usage/sync/","title":"Usage: Sync","text":""},{"location":"usage/sync/#when-to-use-the-sync-verifier","title":"When to Use the Sync Verifier","text":"<p>Use <code>JWTVerifier</code> when your service code is synchronous or when you prefer a sync verification path managed by your framework.</p>"},{"location":"usage/sync/#basic-pattern","title":"Basic Pattern","text":"<pre><code>from oidc_jwt_verifier import AuthConfig, AuthError, JWTVerifier\n\nconfig = AuthConfig(\n    issuer=\"https://issuer.example/\",\n    audience=\"https://api.example\",\n    jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n    allowed_algs=(\"RS256\",),\n)\n\nverifier = JWTVerifier(config)\n\ntry:\n    claims = verifier.verify_access_token(token)\nexcept AuthError as error:\n    status = error.status_code\n    www_authenticate = error.www_authenticate_header(realm=\"api\")\n</code></pre>"},{"location":"usage/sync/#reuse-strategy","title":"Reuse Strategy","text":"<ul> <li>Create one verifier instance per process (or per app instance).</li> <li>Reuse it across requests.</li> <li>Avoid creating a new verifier for each request.</li> </ul>"},{"location":"usage/sync/#multi-audience-scope-and-permission-enforcement","title":"Multi-Audience, Scope, and Permission Enforcement","text":"<p><code>AuthConfig</code> supports:</p> <ul> <li>Multiple accepted audiences.</li> <li>Required scopes.</li> <li>Required permissions.</li> </ul> <pre><code>config = AuthConfig(\n    issuer=\"https://issuer.example/\",\n    audience=(\"https://api-a.example\", \"https://api-b.example\"),\n    jwks_url=\"https://issuer.example/.well-known/jwks.json\",\n    required_scopes=(\"read:users\",),\n    required_permissions=(\"users:read\",),\n)\n</code></pre> <p>Missing scope/permission checks produce <code>AuthError</code> with <code>status_code=403</code>.</p>"},{"location":"usage/sync/#sync-in-asgi-frameworks","title":"Sync in ASGI Frameworks","text":"<p>For FastAPI and Starlette applications, prefer the async verifier. If you need sync verification in FastAPI, use <code>create_sync_bearer_dependency()</code> from FastAPI integration, which can offload to threadpool.</p>"}]}
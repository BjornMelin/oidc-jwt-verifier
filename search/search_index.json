{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"oidc-jwt-verifier","text":"<p>A small, framework-agnostic JWT verification core for OIDC/JWKS issuers.</p> <p><code>oidc-jwt-verifier</code> is designed to be shared by higher-level adapters (Dash, Bottle, Lambda, FastAPI) while keeping security decisions centralized and consistent.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install oidc-jwt-verifier\n</code></pre> <p>For development with documentation tools:</p> <pre><code>pip install oidc-jwt-verifier[docs]\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code>from oidc_jwt_verifier import AuthConfig, JWTVerifier\n\nconfig = AuthConfig(\n    issuer=\"https://example-issuer/\",\n    audience=\"https://example-api\",\n    jwks_url=\"https://example-issuer/.well-known/jwks.json\",\n    allowed_algs=(\"RS256\",),\n    required_scopes=(\"read:users\",),\n)\n\nverifier = JWTVerifier(config)\nclaims = verifier.verify_access_token(token)\n</code></pre>"},{"location":"#secure-by-default-behavior","title":"Secure-by-default behavior","text":"<p>The verifier:</p> <ul> <li>Verifies signature, <code>iss</code>, <code>aud</code>, <code>exp</code>, and <code>nbf</code> (when present).</li> <li>Uses an explicit algorithm allowlist and rejects <code>alg=none</code>.</li> <li>Fails closed on malformed tokens, JWKS fetch errors, timeouts, missing keys, and missing <code>kid</code>.</li> <li>Never derives a JWKS URL from token headers, and rejects tokens that include <code>jku</code>, <code>x5u</code>, or <code>crit</code>.</li> <li>Supports Auth0-style multi-audience tokens (<code>aud</code> as an array) and enforces required scopes and permissions.</li> </ul> <p>Auth0 guidance for API token validation calls out validating the JWT and then checking <code>aud</code> and scopes in the <code>scope</code> claim. See the Auth0 docs for details.</p>"},{"location":"#why-this-library","title":"Why this library","text":"<p>This project focuses on making server-side access token verification reproducible across multiple apps and frameworks by centralizing conservative verification and authorization policy.</p> <p>If you\u2019re deciding between this library and other JWT/OIDC tooling, see Alternatives and rationale.</p>"},{"location":"#error-handling","title":"Error handling","text":"<p>The public exception type is <code>AuthError</code>.</p> <p><code>AuthError</code> carries:</p> <ul> <li><code>code</code>: stable, machine-readable reason</li> <li><code>status_code</code>: <code>401</code> (authentication) or <code>403</code> (authorization)</li> <li><code>www_authenticate_header()</code>: an RFC 6750 compatible <code>WWW-Authenticate</code> value for Bearer auth</li> </ul> <pre><code>from oidc_jwt_verifier import AuthError\n\ntry:\n    claims = verifier.verify_access_token(token)\nexcept AuthError as err:\n    status = err.status_code\n    www_authenticate = err.www_authenticate_header()\n</code></pre>"},{"location":"#references","title":"References","text":"<ul> <li>Auth0: Validate Access Tokens</li> <li>Auth0: Validate JSON Web Tokens</li> <li>RFC 8725: JSON Web Token Best Current Practices</li> <li>RFC 9700: Best Current Practice for OAuth 2.0 Security</li> <li>PyJWT docs and examples</li> </ul>"},{"location":"alternatives/","title":"Alternatives and rationale","text":"<p>This project exists because JWT validation for APIs is easy to get mostly right while still missing important security and interoperability details (algorithm allowlists, unsafe header handling, consistent error responses, and authorization checks like scopes/permissions).</p> <p><code>oidc-jwt-verifier</code> is intentionally small and policy-driven: you provide explicit configuration (<code>issuer</code>, <code>audience</code>, <code>jwks_url</code>, allowed algorithms, and required scopes), and the library applies conservative defaults and consistent error behavior.</p>"},{"location":"alternatives/#scope-and-non-goals","title":"Scope and non-goals","text":"<p>In scope</p> <ul> <li>Verifying signed JWT access tokens for a known OIDC issuer.</li> <li>Fetching signing keys from a configured JWKS URL with caching (via PyJWT\u2019s <code>PyJWKClient</code>).</li> <li>Enforcing claim checks (<code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>) and authorization policy (required scopes and   permissions).</li> <li>Returning an RFC 6750-compatible <code>WWW-Authenticate</code> header via <code>AuthError</code>.</li> </ul> <p>Not in scope</p> <ul> <li>OIDC discovery (<code>.well-known/openid-configuration</code>) or deriving endpoints from the token.</li> <li>Client-side OAuth/OIDC flows, session management, or framework integrations.</li> <li>Async key fetching (this library is synchronous by design).</li> </ul>"},{"location":"alternatives/#comparisons-to-related-packages","title":"Comparisons to related packages","text":""},{"location":"alternatives/#use-pyjwt-directly","title":"Use PyJWT directly","text":"<p>PyJWT is the underlying JWT implementation and provides the core primitives, including <code>PyJWKClient</code> for fetching and caching signing keys from a JWKS endpoint.</p> <ul> <li>PyJWT docs: <code>https://github.com/jpadilla/pyjwt/blob/master/docs/usage.rst</code></li> </ul> <p>Choose PyJWT directly when you want maximum control and are prepared to implement and review your own security policy: allowed algorithms, header restrictions, audience/issuer rules, required scopes/permissions, and consistent API error mapping.</p> <p>Choose <code>oidc-jwt-verifier</code> when you want those policy decisions centralized and reused across multiple apps/frameworks with the same behavior.</p>"},{"location":"alternatives/#verify-oidc-token","title":"<code>verify-oidc-token</code>","text":"<p><code>verify-oidc-token</code> focuses on verifying tokens against an OIDC issuer with a small surface area and provides a CLI.</p> <ul> <li>PyPI: <code>https://pypi.org/project/verify-oidc-token/</code></li> </ul> <p>It\u2019s a reasonable choice for scripts and lightweight checks; <code>oidc-jwt-verifier</code> is optimized for server-side API enforcement (repeatable policy + API-friendly errors) rather than being a minimal verification utility.</p>"},{"location":"alternatives/#py-jwt-verifier","title":"<code>py-jwt-verifier</code>","text":"<p><code>py-jwt-verifier</code> supports multiple identity providers and uses OIDC configuration discovery to find <code>jwks_uri</code>, with caching via <code>requests_cache</code>.</p> <ul> <li>PyPI: <code>https://pypi.org/project/py-jwt-verifier/</code></li> </ul> <p>If you want discovery-driven configuration and a more \u201cIdP-agnostic out of the box\u201d flow, <code>py-jwt-verifier</code> may be a better fit. If you prefer explicit configuration (never deriving a JWKS URL from token contents/headers) and a small verifier you can embed across frameworks, <code>oidc-jwt-verifier</code> is the intended fit.</p>"},{"location":"alternatives/#flask-oidc-verifier","title":"<code>flask-oidc-verifier</code>","text":"<p><code>flask-oidc-verifier</code> targets Flask specifically.</p> <ul> <li>PyPI: <code>https://pypi.org/project/flask-oidc-verifier/</code></li> </ul> <p>If you\u2019re all-in on Flask and want an opinionated integration, a framework-specific package can be a good choice. <code>oidc-jwt-verifier</code> is framework-agnostic on purpose so you can share the same policy across different runtimes (e.g., WSGI, ASGI, Lambda).</p>"},{"location":"alternatives/#verify-oidc-identity","title":"<code>verify-oidc-identity</code>","text":"<p><code>verify-oidc-identity</code> is oriented around verifying OIDC ID tokens (identity assertions) and supports both sync and async flows.</p> <ul> <li>PyPI: <code>https://pypi.org/project/verify-oidc-identity/</code></li> </ul> <p>If you are primarily validating ID tokens (authentication), prefer an ID-token-oriented library. If you\u2019re validating API access tokens and enforcing scopes/permissions, <code>oidc-jwt-verifier</code> stays focused on that server-side use case.</p>"},{"location":"alternatives/#general-josejwt-libraries-authlib-joserfc-python-jose","title":"General JOSE/JWT libraries (<code>Authlib</code>, <code>joserfc</code>, <code>python-jose</code>)","text":"<p>General-purpose JOSE/JWT libraries are good foundations, but they typically expect you to supply key material and policy rather than providing an API-token verifier with JWKS fetching behavior and API error conventions.</p> <ul> <li>Authlib (JOSE/JWT): <code>https://docs.authlib.org/en/latest/jose/jwt.html</code></li> <li>joserfc: <code>https://pypi.org/project/joserfc/</code></li> <li>python-jose: <code>https://pypi.org/project/python-jose/</code></li> </ul> <p>Choose these when you\u2019re building a broader auth stack or need advanced JOSE features. Choose <code>oidc-jwt-verifier</code> when you want a small, opinionated verification core for API access tokens.</p>"},{"location":"alternatives/#async-key-fetching-pyjwt-key-fetcher","title":"Async key fetching: <code>pyjwt-key-fetcher</code>","text":"<p>If you specifically need async JWKS fetching and want something \u201cPyJWT-shaped\u201d, <code>pyjwt-key-fetcher</code> positions itself as an async alternative to <code>PyJWKClient</code> and can retrieve OIDC configuration (to find <code>jwks_uri</code>).</p> <ul> <li>PyPI: <code>https://pypi.org/project/pyjwt-key-fetcher/</code></li> </ul>"},{"location":"alternatives/#why-use-oidc-jwt-verifier","title":"Why use <code>oidc-jwt-verifier</code>","text":"<p>Use this library when you want:</p> <ul> <li>A single, reusable verifier across frameworks with explicit issuer/audience/JWKS configuration.</li> <li>Conservative defaults around algorithm allowlists and header handling (fail closed).</li> <li>Built-in enforcement for scopes/permissions and consistent API-friendly errors (<code>AuthError</code>).</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#013-2025-12-18","title":"0.1.3 (2025-12-18)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>docs: add missing Documentation badge to docs/index.md (dfdf6ae)</li> </ul>"},{"location":"changelog/#012-2025-12-18","title":"0.1.2 (2025-12-18)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>docs: resolve MkDocs Material rendering issues and modernize deployment (89fefb0)</li> <li>docs: resolve MkDocs Material rendering issues and modernize deployment (2018920)</li> </ul>"},{"location":"changelog/#011-2025-12-18","title":"0.1.1 (2025-12-18)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>add core JWT verification library with automated release pipeline (61862b5)</li> <li>jwt-verifier: add core JWT verification library (cf67629)</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>address additional PR review comments (f8132f8)</li> <li>address PR review comments (b12bf0a)</li> <li>persist stripped scope_claim and permissions_claim values (c8290c5)</li> <li>update PyJWT to &gt;=2.10.1 to address CVE-2024-53861 (3fe5e8f)</li> <li>verifier: catch DecodeError in header parse (df76b3c)</li> <li>verifier: narrow decode exceptions in audience loop (d2a9fd5)</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<ul> <li>Initial release of the shared JWT verification core.</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>This page documents the public API of the <code>oidc-jwt-verifier</code> library.</p>"},{"location":"reference/#public-api","title":"Public API","text":"<p>The library exports three main components:</p> <ul> <li><code>AuthConfig</code> - Configuration dataclass for JWT verification settings</li> <li><code>AuthError</code> - Exception type for authentication/authorization failures</li> <li><code>JWTVerifier</code> - Main verifier class for validating JWTs</li> </ul>"},{"location":"reference/#configuration","title":"Configuration","text":""},{"location":"reference/#oidc_jwt_verifier.AuthConfig","title":"<code>AuthConfig(issuer: str, audience: str | Sequence[str], jwks_url: str, allowed_algs: Sequence[str] = ('RS256',), leeway_s: int = 0, jwks_timeout_s: int = 3, jwks_cache_ttl_s: int = 300, jwks_max_cached_keys: int = 16, required_scopes: Sequence[str] = (), required_permissions: Sequence[str] = (), scope_claim: str = 'scope', permissions_claim: str = 'permissions')</code>  <code>dataclass</code>","text":"<p>Immutable configuration for JWT verification.</p> <p>This dataclass holds all settings required by <code>JWTVerifier</code> to validate JWTs against an OIDC provider. The configuration is frozen (immutable) and uses slots for memory efficiency.</p> <p>All string inputs are stripped of leading/trailing whitespace during validation. Sequences are normalized to tuples.</p> <p>Attributes:</p> Name Type Description <code>issuer</code> <code>str</code> <p>The expected <code>iss</code> claim value. Must match the token issuer exactly. Typically the OIDC provider URL (e.g., <code>https://example.auth0.com/</code>).</p> <code>audience</code> <code>str | Sequence[str]</code> <p>One or more expected <code>aud</code> claim values. The token must contain at least one matching audience. Accepts a single string or a sequence of strings.</p> <code>jwks_url</code> <code>str</code> <p>The URL to fetch the JSON Web Key Set from. This URL is used for all key lookups; the verifier never derives JWKS URLs from token headers.</p> <code>allowed_algs</code> <code>Sequence[str]</code> <p>Permitted signing algorithms. Defaults to <code>(\"RS256\",)</code>. The <code>none</code> algorithm is always rejected regardless of this setting.</p> <code>leeway_s</code> <code>int</code> <p>Clock skew tolerance in seconds for <code>exp</code> and <code>nbf</code> claim validation. Defaults to 0.</p> <code>jwks_timeout_s</code> <code>int</code> <p>HTTP timeout in seconds for JWKS fetches. Defaults to 3.</p> <code>jwks_cache_ttl_s</code> <code>int</code> <p>Time-to-live in seconds for cached JWKS data. Must be in the range (0, 86400]. Defaults to 300.</p> <code>jwks_max_cached_keys</code> <code>int</code> <p>Maximum number of signing keys to cache. Must be in the range (0, 1024]. Defaults to 16.</p> <code>required_scopes</code> <code>Sequence[str]</code> <p>Scopes that must be present in the token for authorization to succeed. Checked against the <code>scope_claim</code>. Defaults to an empty tuple (no scope requirements).</p> <code>required_permissions</code> <code>Sequence[str]</code> <p>Permissions that must be present in the token. Checked against the <code>permissions_claim</code>. Defaults to an empty tuple.</p> <code>scope_claim</code> <code>str</code> <p>The claim name containing OAuth 2.0 scopes. Defaults to <code>\"scope\"</code>.</p> <code>permissions_claim</code> <code>str</code> <p>The claim name containing permissions (commonly used by Auth0). Defaults to <code>\"permissions\"</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any validation constraint is violated during construction. Specific conditions include: - Empty or whitespace-only <code>issuer</code>, <code>jwks_url</code>, or   <code>audience</code>. - Empty or whitespace-only <code>allowed_algs</code>, or inclusion of   the <code>none</code> algorithm. - Negative <code>leeway_s</code>. - Non-positive <code>jwks_timeout_s</code>. - <code>jwks_cache_ttl_s</code> outside (0, 86400]. - <code>jwks_max_cached_keys</code> outside (0, 1024]. - Empty or whitespace-only <code>scope_claim</code> or   <code>permissions_claim</code>.</p> <p>Examples:</p> <p>Minimal configuration for Auth0:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; config.audiences\n('https://api.example.com',)\n&gt;&gt;&gt; config.allowed_algorithms\n('RS256',)\n</code></pre> <p>Configuration with multiple audiences and scope requirements:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=[\"https://api.example.com\", \"https://api2.example.com\"],\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     allowed_algs=[\"RS256\", \"RS384\"],\n...     required_scopes=[\"read:users\", \"write:users\"],\n... )\n&gt;&gt;&gt; config.audiences\n('https://api.example.com', 'https://api2.example.com')\n&gt;&gt;&gt; config.required_scope_set\n{'read:users', 'write:users'}\n</code></pre> <p>Invalid configuration raises ValueError:</p> <pre><code>&gt;&gt;&gt; AuthConfig(\n...     issuer=\"\",\n...     audience=\"api\",\n...     jwks_url=\"https://example.com/.well-known/jwks.json\",\n... )\nTraceback (most recent call last):\n    ...\nValueError: issuer must be non-empty\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.audiences","title":"<code>audiences: tuple[str, ...]</code>  <code>property</code>","text":"<p>Return the configured audiences as a tuple.</p> <p>This property provides consistent tuple access regardless of whether the <code>audience</code> attribute was initialized with a single string or a sequence.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple of audience strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; config.audiences\n('https://api.example.com',)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.allowed_algorithms","title":"<code>allowed_algorithms: tuple[str, ...]</code>  <code>property</code>","text":"<p>Return the allowed algorithms as a tuple.</p> <p>This property provides consistent tuple access regardless of whether the <code>allowed_algs</code> attribute was initialized with a single string or a sequence.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple of algorithm name strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     allowed_algs=[\"RS256\", \"ES256\"],\n... )\n&gt;&gt;&gt; config.allowed_algorithms\n('RS256', 'ES256')\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.required_scope_set","title":"<code>required_scope_set: set[str]</code>  <code>property</code>","text":"<p>Return the required scopes as a set for efficient membership testing.</p> <p>Empty strings in the <code>required_scopes</code> sequence are filtered out.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of non-empty scope strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     required_scopes=[\"read:users\", \"write:users\"],\n... )\n&gt;&gt;&gt; config.required_scope_set == {\"read:users\", \"write:users\"}\nTrue\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.required_permission_set","title":"<code>required_permission_set: set[str]</code>  <code>property</code>","text":"<p>Return the required permissions as a set for efficient membership testing.</p> <p>Empty strings in the <code>required_permissions</code> sequence are filtered out.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of non-empty permission strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     required_permissions=[\"admin\", \"editor\"],\n... )\n&gt;&gt;&gt; config.required_permission_set == {\"admin\", \"editor\"}\nTrue\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthConfig.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"<p>Validate and normalize configuration values after initialization.</p> <p>This method runs automatically after dataclass initialization. It strips whitespace from string values, normalizes sequences to tuples, and validates all constraints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any validation constraint is violated.</p> Source code in <code>oidc_jwt_verifier/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate and normalize configuration values after initialization.\n\n    This method runs automatically after dataclass initialization. It\n    strips whitespace from string values, normalizes sequences to tuples,\n    and validates all constraints.\n\n    Raises:\n        ValueError: If any validation constraint is violated.\n    \"\"\"\n    issuer = self.issuer.strip()\n    if not issuer:\n        raise ValueError(\"issuer must be non-empty\")\n    object.__setattr__(self, \"issuer\", issuer)\n\n    jwks_url = self.jwks_url.strip()\n    if not jwks_url:\n        raise ValueError(\"jwks_url must be non-empty\")\n    object.__setattr__(self, \"jwks_url\", jwks_url)\n\n    audiences = tuple(a.strip() for a in _normalize_str_sequence(self.audience))\n    if not audiences or any(not a for a in audiences):\n        raise ValueError(\"audience must be non-empty\")\n    object.__setattr__(self, \"audience\", audiences)\n\n    allowed_algs = tuple(a.strip() for a in _normalize_str_sequence(self.allowed_algs))\n    if not allowed_algs or any(not a for a in allowed_algs):\n        raise ValueError(\"allowed_algs must be non-empty\")\n    if any(a.lower() == \"none\" for a in allowed_algs):\n        raise ValueError(\"allowed_algs must not include 'none'\")\n    object.__setattr__(self, \"allowed_algs\", allowed_algs)\n\n    if self.leeway_s &lt; 0:\n        raise ValueError(\"leeway_s must be &gt;= 0\")\n\n    if self.jwks_timeout_s &lt;= 0:\n        raise ValueError(\"jwks_timeout_s must be &gt; 0\")\n    if not 0 &lt; self.jwks_cache_ttl_s &lt;= 24 * 60 * 60:\n        raise ValueError(\"jwks_cache_ttl_s must be in (0, 86400]\")\n    if not 0 &lt; self.jwks_max_cached_keys &lt;= 1024:\n        raise ValueError(\"jwks_max_cached_keys must be in (0, 1024]\")\n\n    object.__setattr__(\n        self,\n        \"required_scopes\",\n        tuple(s.strip() for s in _normalize_str_sequence(self.required_scopes)),\n    )\n    object.__setattr__(\n        self,\n        \"required_permissions\",\n        tuple(p.strip() for p in _normalize_str_sequence(self.required_permissions)),\n    )\n\n    scope_claim = self.scope_claim.strip()\n    if not scope_claim:\n        raise ValueError(\"scope_claim must be non-empty\")\n    object.__setattr__(self, \"scope_claim\", scope_claim)\n\n    permissions_claim = self.permissions_claim.strip()\n    if not permissions_claim:\n        raise ValueError(\"permissions_claim must be non-empty\")\n    object.__setattr__(self, \"permissions_claim\", permissions_claim)\n</code></pre>"},{"location":"reference/#errors","title":"Errors","text":""},{"location":"reference/#oidc_jwt_verifier.AuthError","title":"<code>AuthError(*, code: str, message: str, status_code: int, required_scopes: Iterable[str] = (), required_permissions: Iterable[str] = ())</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised on authentication or authorization failure.</p> <p>This exception provides structured error information including a stable error code for programmatic handling, an HTTP status code (401 for authentication failures, 403 for authorization failures), and a method to generate RFC 6750-compliant WWW-Authenticate header values.</p> <p>The exception message is accessible via the standard <code>str()</code> conversion or the <code>message</code> attribute.</p> <p>Attributes:</p> Name Type Description <code>code</code> <p>A stable string identifier for the error type. Common values include <code>\"invalid_token\"</code>, <code>\"token_expired\"</code>, <code>\"insufficient_scope\"</code>, and <code>\"missing_token\"</code>. Suitable for programmatic error handling and logging.</p> <code>message</code> <p>A human-readable description of the error. This is also set as the exception message.</p> <code>status_code</code> <p>The HTTP status code to return. Must be 401 (Unauthorized) for authentication errors or 403 (Forbidden) for authorization errors.</p> <code>required_scopes</code> <p>A tuple of scope strings that were required but missing from the token. Populated for <code>insufficient_scope</code> errors; empty for other error types.</p> <code>required_permissions</code> <p>A tuple of permission strings that were required but missing from the token. Populated for <code>insufficient_permissions</code> errors; empty for other error types.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>status_code</code> is not 401 or 403.</p> <p>Examples:</p> <p>Creating an authentication error (401):</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"token_expired\",\n...     message=\"Token is expired\",\n...     status_code=401,\n... )\n&gt;&gt;&gt; str(error)\n'Token is expired'\n&gt;&gt;&gt; error.code\n'token_expired'\n&gt;&gt;&gt; error.status_code\n401\n</code></pre> <p>Creating an authorization error (403) with scope requirements:</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"insufficient_scope\",\n...     message=\"Insufficient scope\",\n...     status_code=403,\n...     required_scopes=[\"read:users\", \"write:users\"],\n... )\n&gt;&gt;&gt; error.required_scopes\n('read:users', 'write:users')\n</code></pre> <p>Generating a WWW-Authenticate header:</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"invalid_token\",\n...     message=\"Malformed token\",\n...     status_code=401,\n... )\n&gt;&gt;&gt; error.www_authenticate_header(realm=\"api\")\n'Bearer realm=\"api\", error=\"invalid_token\", error_description=\"Malformed token\"'\n</code></pre> <p>Invalid status code raises ValueError:</p> <pre><code>&gt;&gt;&gt; AuthError(code=\"error\", message=\"msg\", status_code=500)\nTraceback (most recent call last):\n    ...\nValueError: status_code must be 401 or 403\n</code></pre> <p>Initialize an authentication or authorization error.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>A stable string identifier for the error type.</p> required <code>message</code> <code>str</code> <p>A human-readable error description.</p> required <code>status_code</code> <code>int</code> <p>The HTTP status code (must be 401 or 403).</p> required <code>required_scopes</code> <code>Iterable[str]</code> <p>Scopes that were required but missing. Defaults to an empty tuple.</p> <code>()</code> <code>required_permissions</code> <code>Iterable[str]</code> <p>Permissions that were required but missing. Defaults to an empty tuple.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>status_code</code> is not 401 or 403.</p> Source code in <code>oidc_jwt_verifier/errors.py</code> <pre><code>def __init__(\n    self,\n    *,\n    code: str,\n    message: str,\n    status_code: int,\n    required_scopes: Iterable[str] = (),\n    required_permissions: Iterable[str] = (),\n) -&gt; None:\n    \"\"\"Initialize an authentication or authorization error.\n\n    Args:\n        code: A stable string identifier for the error type.\n        message: A human-readable error description.\n        status_code: The HTTP status code (must be 401 or 403).\n        required_scopes: Scopes that were required but missing.\n            Defaults to an empty tuple.\n        required_permissions: Permissions that were required but missing.\n            Defaults to an empty tuple.\n\n    Raises:\n        ValueError: If ``status_code`` is not 401 or 403.\n    \"\"\"\n    if status_code not in (401, 403):\n        raise ValueError(\"status_code must be 401 or 403\")\n    super().__init__(message)\n    self.code = code\n    self.message = message\n    self.status_code = status_code\n    self.required_scopes = tuple(required_scopes)\n    self.required_permissions = tuple(required_permissions)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.AuthError.www_authenticate_header","title":"<code>www_authenticate_header(*, realm: str | None = None) -&gt; str</code>","text":"<p>Generate an RFC 6750-compliant WWW-Authenticate header value.</p> <p>Constructs a Bearer authentication challenge suitable for use as the value of an HTTP WWW-Authenticate header. The challenge includes the error type (mapped to RFC 6750 error codes) and a description.</p> <p>RFC 6750 defines two relevant error codes: - <code>invalid_token</code>: Used for 401 errors (authentication failures). - <code>insufficient_scope</code>: Used for 403 errors (authorization failures).</p> <p>If <code>required_scopes</code> is non-empty, a <code>scope</code> parameter is included listing the missing scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm</code> <code>str | None</code> <p>Optional protection space identifier. If provided, it appears first in the challenge parameters. Common values include the API name or domain.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string suitable for use as the WWW-Authenticate header value.</p> <code>str</code> <p>The format is <code>Bearer param1=\"value1\", param2=\"value2\", ...</code>.</p> <p>Examples:</p> <p>Basic authentication error:</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"invalid_token\",\n...     message=\"Token is expired\",\n...     status_code=401,\n... )\n&gt;&gt;&gt; error.www_authenticate_header()\n'Bearer error=\"invalid_token\", error_description=\"Token is expired\"'\n</code></pre> <p>With realm:</p> <pre><code>&gt;&gt;&gt; error.www_authenticate_header(realm=\"my-api\")\n'Bearer realm=\"my-api\", error=\"invalid_token\", error_description=\"Token is expired\"'\n</code></pre> <p>Authorization error with required scopes:</p> <pre><code>&gt;&gt;&gt; error = AuthError(\n...     code=\"insufficient_scope\",\n...     message=\"Insufficient scope\",\n...     status_code=403,\n...     required_scopes=[\"read:users\"],\n... )\n&gt;&gt;&gt; header = error.www_authenticate_header()\n&gt;&gt;&gt; \"insufficient_scope\" in header\nTrue\n&gt;&gt;&gt; \"read:users\" in header\nTrue\n</code></pre> Source code in <code>oidc_jwt_verifier/errors.py</code> <pre><code>def www_authenticate_header(self, *, realm: str | None = None) -&gt; str:\n    \"\"\"Generate an RFC 6750-compliant WWW-Authenticate header value.\n\n    Constructs a Bearer authentication challenge suitable for use as the\n    value of an HTTP WWW-Authenticate header. The challenge includes\n    the error type (mapped to RFC 6750 error codes) and a description.\n\n    RFC 6750 defines two relevant error codes:\n    - ``invalid_token``: Used for 401 errors (authentication failures).\n    - ``insufficient_scope``: Used for 403 errors (authorization failures).\n\n    If ``required_scopes`` is non-empty, a ``scope`` parameter is\n    included listing the missing scopes.\n\n    Args:\n        realm: Optional protection space identifier. If provided, it\n            appears first in the challenge parameters. Common values\n            include the API name or domain.\n\n    Returns:\n        A string suitable for use as the WWW-Authenticate header value.\n        The format is ``Bearer param1=\"value1\", param2=\"value2\", ...``.\n\n    Examples:\n        Basic authentication error:\n\n        &gt;&gt;&gt; error = AuthError(\n        ...     code=\"invalid_token\",\n        ...     message=\"Token is expired\",\n        ...     status_code=401,\n        ... )\n        &gt;&gt;&gt; error.www_authenticate_header()\n        'Bearer error=\"invalid_token\", error_description=\"Token is expired\"'\n\n        With realm:\n\n        &gt;&gt;&gt; error.www_authenticate_header(realm=\"my-api\")\n        'Bearer realm=\"my-api\", error=\"invalid_token\", error_description=\"Token is expired\"'\n\n        Authorization error with required scopes:\n\n        &gt;&gt;&gt; error = AuthError(\n        ...     code=\"insufficient_scope\",\n        ...     message=\"Insufficient scope\",\n        ...     status_code=403,\n        ...     required_scopes=[\"read:users\"],\n        ... )\n        &gt;&gt;&gt; header = error.www_authenticate_header()\n        &gt;&gt;&gt; \"insufficient_scope\" in header\n        True\n        &gt;&gt;&gt; \"read:users\" in header\n        True\n    \"\"\"\n    params: list[str] = []\n    if realm is not None:\n        params.append(f\"realm={_quote_rfc6750_value(realm)}\")\n\n    if self.status_code == 403:\n        rfc6750_error = \"insufficient_scope\"\n    else:\n        rfc6750_error = \"invalid_token\"\n\n    params.append(f\"error={_quote_rfc6750_value(rfc6750_error)}\")\n    params.append(f\"error_description={_quote_rfc6750_value(self.message)}\")\n\n    if self.required_scopes:\n        scope_str = \" \".join(self.required_scopes)\n        params.append(f\"scope={_quote_rfc6750_value(scope_str)}\")\n\n    if self.required_permissions:\n        permissions_str = \" \".join(self.required_permissions)\n        params.append(f\"permissions={_quote_rfc6750_value(permissions_str)}\")\n\n    return \"Bearer \" + \", \".join(params)\n</code></pre>"},{"location":"reference/#verifier","title":"Verifier","text":""},{"location":"reference/#oidc_jwt_verifier.JWTVerifier","title":"<code>JWTVerifier(config: AuthConfig)</code>","text":"<p>Stateful JWT verifier for OIDC access tokens.</p> <p>This class performs complete JWT verification including:</p> <ol> <li>Header validation: Rejects tokens with dangerous headers    (<code>jku</code>, <code>x5u</code>, <code>crit</code>) and ensures the algorithm is in the    allowlist.</li> <li>Key retrieval: Fetches the signing key from the JWKS using the    token's <code>kid</code> header.</li> <li>Signature verification: Validates the cryptographic signature.</li> <li>Claim validation: Checks <code>iss</code>, <code>aud</code>, <code>exp</code>, and <code>nbf</code>    claims against configuration.</li> <li>Authorization enforcement: Verifies required scopes and    permissions are present (returns 403 on failure).</li> </ol> <p>The verifier maintains a cached JWKS client for efficient key lookups across multiple token verifications.</p> <p>Attributes:</p> Name Type Description <code>_config</code> <p>The authentication configuration.</p> <code>_jwks</code> <p>The JWKS client for signing key retrieval.</p> <p>Examples:</p> <p>Basic token verification:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig, AuthError, JWTVerifier\n&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; verifier = JWTVerifier(config)\n&gt;&gt;&gt; claims = verifier.verify_access_token(token)\n&gt;&gt;&gt; claims[\"sub\"]\n'auth0|123456789'\n</code></pre> <p>Handling verification errors:</p> <pre><code>&gt;&gt;&gt; try:\n...     claims = verifier.verify_access_token(expired_token)\n... except AuthError as e:\n...     print(f\"Error: {e.code}, Status: {e.status_code}\")\n...     print(e.www_authenticate_header())\nError: token_expired, Status: 401\nBearer error=\"invalid_token\", error_description=\"Token is expired\"\n</code></pre> <p>Verifying tokens with scope requirements:</p> <pre><code>&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n...     required_scopes=[\"read:users\"],\n... )\n&gt;&gt;&gt; verifier = JWTVerifier(config)\n&gt;&gt;&gt; # Token without required scopes raises AuthError with 403\n&gt;&gt;&gt; claims = verifier.verify_access_token(token_without_scopes)\nTraceback (most recent call last):\n    ...\nAuthError: Insufficient scope\n</code></pre> <p>Initialize a JWT verifier with the given configuration.</p> <p>Creates a JWKS client configured with the caching parameters from the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AuthConfig</code> <p>The authentication configuration specifying the issuer, audience, JWKS URL, allowed algorithms, and authorization requirements.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig\n&gt;&gt;&gt; config = AuthConfig(\n...     issuer=\"https://example.auth0.com/\",\n...     audience=\"https://api.example.com\",\n...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n... )\n&gt;&gt;&gt; verifier = JWTVerifier(config)\n</code></pre> Source code in <code>oidc_jwt_verifier/verifier.py</code> <pre><code>def __init__(self, config: AuthConfig) -&gt; None:\n    \"\"\"Initialize a JWT verifier with the given configuration.\n\n    Creates a JWKS client configured with the caching parameters\n    from the provided configuration.\n\n    Args:\n        config: The authentication configuration specifying the\n            issuer, audience, JWKS URL, allowed algorithms, and\n            authorization requirements.\n\n    Examples:\n        &gt;&gt;&gt; from oidc_jwt_verifier import AuthConfig\n        &gt;&gt;&gt; config = AuthConfig(\n        ...     issuer=\"https://example.auth0.com/\",\n        ...     audience=\"https://api.example.com\",\n        ...     jwks_url=\"https://example.auth0.com/.well-known/jwks.json\",\n        ... )\n        &gt;&gt;&gt; verifier = JWTVerifier(config)  # doctest: +SKIP\n    \"\"\"\n    self._config = config\n    self._jwks = JWKSClient.from_config(config)\n</code></pre>"},{"location":"reference/#oidc_jwt_verifier.JWTVerifier.verify_access_token","title":"<code>verify_access_token(token: str) -&gt; dict[str, Any]</code>","text":"<p>Verify an access token and return its claims.</p> <p>Performs the complete verification chain:</p> <ol> <li>Validates the token is non-empty.</li> <li>Parses and validates the token header (rejects <code>jku</code>, <code>x5u</code>,    <code>crit</code>; validates <code>alg</code> and <code>kid</code>).</li> <li>Fetches the signing key from the JWKS.</li> <li>Decodes and verifies the token signature.</li> <li>Validates standard claims (<code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>).</li> <li>Enforces required scopes and permissions.</li> </ol> <p>The method supports Auth0-style multi-audience tokens where the <code>aud</code> claim is an array. Verification succeeds if any configured audience matches any audience in the token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The encoded JWT access token string. Leading and trailing whitespace is stripped.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The decoded token payload as a dictionary. Contains all</p> <code>dict[str, Any]</code> <p>claims from the token including registered claims (<code>iss</code>,</p> <code>dict[str, Any]</code> <p><code>sub</code>, <code>aud</code>, <code>exp</code>, etc.) and any custom claims.</p> <p>Raises:</p> Type Description <code>AuthError</code> <p>On any verification failure. The error's <code>status_code</code> indicates the appropriate HTTP response: - 401 for authentication failures (missing token,   malformed token, invalid signature, expired token,   wrong issuer/audience). - 403 for authorization failures (insufficient scopes   or permissions).</p> <p>Specific error codes include: - <code>\"missing_token\"</code>: Empty or whitespace-only token. - <code>\"malformed_token\"</code>: Unparseable token or missing   <code>alg</code> header. - <code>\"forbidden_header\"</code>: Token contains <code>jku</code>,   <code>x5u</code>, or <code>crit</code> headers. - <code>\"disallowed_alg\"</code>: Algorithm not in allowlist or   is <code>none</code>. - <code>\"missing_kid\"</code>: Token lacks <code>kid</code> header. - <code>\"token_expired\"</code>: Token <code>exp</code> is in the past. - <code>\"token_not_yet_valid\"</code>: Token <code>nbf</code> is in the   future. - <code>\"invalid_issuer\"</code>: <code>iss</code> claim mismatch. - <code>\"invalid_audience\"</code>: <code>aud</code> claim mismatch. - <code>\"insufficient_scope\"</code>: Missing required scopes. - <code>\"insufficient_permissions\"</code>: Missing required   permissions.</p> <p>Examples:</p> <p>Successful verification:</p> <pre><code>&gt;&gt;&gt; claims = verifier.verify_access_token(valid_token)\n&gt;&gt;&gt; claims[\"sub\"]\n'auth0|123456789'\n&gt;&gt;&gt; claims[\"aud\"]\n'https://api.example.com'\n</code></pre> <p>Missing token:</p> <pre><code>&gt;&gt;&gt; verifier.verify_access_token(\"\")\nTraceback (most recent call last):\n    ...\nAuthError: Missing access token\n</code></pre> <p>Expired token:</p> <pre><code>&gt;&gt;&gt; verifier.verify_access_token(expired_token)\nTraceback (most recent call last):\n    ...\nAuthError: Token is expired\n</code></pre> Source code in <code>oidc_jwt_verifier/verifier.py</code> <pre><code>def verify_access_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Verify an access token and return its claims.\n\n    Performs the complete verification chain:\n\n    1. Validates the token is non-empty.\n    2. Parses and validates the token header (rejects ``jku``, ``x5u``,\n       ``crit``; validates ``alg`` and ``kid``).\n    3. Fetches the signing key from the JWKS.\n    4. Decodes and verifies the token signature.\n    5. Validates standard claims (``iss``, ``aud``, ``exp``, ``nbf``).\n    6. Enforces required scopes and permissions.\n\n    The method supports Auth0-style multi-audience tokens where the\n    ``aud`` claim is an array. Verification succeeds if any configured\n    audience matches any audience in the token.\n\n    Args:\n        token: The encoded JWT access token string. Leading and\n            trailing whitespace is stripped.\n\n    Returns:\n        The decoded token payload as a dictionary. Contains all\n        claims from the token including registered claims (``iss``,\n        ``sub``, ``aud``, ``exp``, etc.) and any custom claims.\n\n    Raises:\n        AuthError: On any verification failure. The error's\n            ``status_code`` indicates the appropriate HTTP response:\n            - 401 for authentication failures (missing token,\n              malformed token, invalid signature, expired token,\n              wrong issuer/audience).\n            - 403 for authorization failures (insufficient scopes\n              or permissions).\n\n            Specific error codes include:\n            - ``\"missing_token\"``: Empty or whitespace-only token.\n            - ``\"malformed_token\"``: Unparseable token or missing\n              ``alg`` header.\n            - ``\"forbidden_header\"``: Token contains ``jku``,\n              ``x5u``, or ``crit`` headers.\n            - ``\"disallowed_alg\"``: Algorithm not in allowlist or\n              is ``none``.\n            - ``\"missing_kid\"``: Token lacks ``kid`` header.\n            - ``\"token_expired\"``: Token ``exp`` is in the past.\n            - ``\"token_not_yet_valid\"``: Token ``nbf`` is in the\n              future.\n            - ``\"invalid_issuer\"``: ``iss`` claim mismatch.\n            - ``\"invalid_audience\"``: ``aud`` claim mismatch.\n            - ``\"insufficient_scope\"``: Missing required scopes.\n            - ``\"insufficient_permissions\"``: Missing required\n              permissions.\n\n    Examples:\n        Successful verification:\n\n        &gt;&gt;&gt; claims = verifier.verify_access_token(valid_token)  # doctest: +SKIP\n        &gt;&gt;&gt; claims[\"sub\"]  # doctest: +SKIP\n        'auth0|123456789'\n        &gt;&gt;&gt; claims[\"aud\"]  # doctest: +SKIP\n        'https://api.example.com'\n\n        Missing token:\n\n        &gt;&gt;&gt; verifier.verify_access_token(\"\")  # doctest: +SKIP\n        Traceback (most recent call last):\n            ...\n        AuthError: Missing access token\n\n        Expired token:\n\n        &gt;&gt;&gt; verifier.verify_access_token(expired_token)  # doctest: +SKIP\n        Traceback (most recent call last):\n            ...\n        AuthError: Token is expired\n    \"\"\"\n    token = token.strip()\n    if not token:\n        raise AuthError(code=\"missing_token\", message=\"Missing access token\", status_code=401)\n\n    # Parse the header without verifying the signature.\n    try:\n        header = jwt.get_unverified_header(token)\n    except jwt.exceptions.DecodeError as exc:\n        raise AuthError(\n            code=\"malformed_token\",\n            message=\"Malformed token\",\n            status_code=401,\n        ) from exc\n\n    # Reject dangerous header parameters that could be used for attacks.\n    # - jku: URL to fetch keys from (could point to attacker-controlled server)\n    # - x5u: URL to fetch X.509 certificate (same risk as jku)\n    # - crit: Critical headers that must be understood (complexity attack vector)\n    if \"jku\" in header or \"x5u\" in header or \"crit\" in header:\n        raise AuthError(\n            code=\"forbidden_header\",\n            message=\"Forbidden token header parameter\",\n            status_code=401,\n        )\n\n    # Validate the algorithm header.\n    alg = header.get(\"alg\")\n    if not isinstance(alg, str) or not alg:\n        raise AuthError(code=\"malformed_token\", message=\"Missing alg header\", status_code=401)\n    if alg.lower() == \"none\":\n        raise AuthError(\n            code=\"disallowed_alg\",\n            message=\"Disallowed signing algorithm\",\n            status_code=401,\n        )\n    if alg not in self._config.allowed_algorithms:\n        raise AuthError(\n            code=\"disallowed_alg\",\n            message=\"Disallowed signing algorithm\",\n            status_code=401,\n        )\n\n    # Require kid header for JWKS key lookup.\n    kid = header.get(\"kid\")\n    if not isinstance(kid, str) or not kid:\n        raise AuthError(code=\"missing_kid\", message=\"Missing kid header\", status_code=401)\n\n    # Fetch the signing key from the JWKS.\n    signing_key = self._jwks.get_signing_key_from_jwt(token)\n\n    # Configure PyJWT verification options.\n    options = {\n        \"require\": [\"exp\", \"iss\", \"aud\"],\n        \"verify_signature\": True,\n        \"verify_exp\": True,\n        \"verify_nbf\": True,\n        \"verify_aud\": True,\n        \"verify_iss\": True,\n        \"strict_aud\": False,  # Allow aud to be array (Auth0 style)\n    }\n\n    # Try each configured audience until one matches.\n    # This handles tokens with array aud claims.\n    payload: dict[str, Any] | None = None\n    last_exc: Exception | None = None\n    for audience in self._config.audiences:\n        try:\n            payload = jwt.decode(\n                token,\n                signing_key.key,\n                algorithms=[alg],\n                audience=audience,\n                issuer=self._config.issuer,\n                leeway=self._config.leeway_s,\n                options=options,\n            )\n            break\n        except jwt.InvalidAudienceError as exc:\n            last_exc = exc\n            continue\n        except jwt.PyJWTError as exc:\n            raise _map_decode_error(exc) from exc\n\n    if payload is None:\n        raise _map_decode_error(last_exc or jwt.InvalidAudienceError(\"invalid audience\"))\n\n    # Enforce required scopes (403 on failure).\n    required_scopes = self._config.required_scope_set\n    required_permissions = self._config.required_permission_set\n\n    token_scopes = _parse_scope_claim(payload.get(self._config.scope_claim))\n    token_permissions = _parse_permissions_claim(payload.get(self._config.permissions_claim))\n\n    missing_scopes = required_scopes - token_scopes\n    if missing_scopes:\n        raise AuthError(\n            code=\"insufficient_scope\",\n            message=\"Insufficient scope\",\n            status_code=403,\n            required_scopes=tuple(sorted(missing_scopes)),\n        )\n\n    # Enforce required permissions (403 on failure).\n    missing_permissions = required_permissions - token_permissions\n    if missing_permissions:\n        raise AuthError(\n            code=\"insufficient_permissions\",\n            message=\"Insufficient permissions\",\n            status_code=403,\n            required_permissions=tuple(sorted(missing_permissions)),\n        )\n\n    return payload\n</code></pre>"}]}